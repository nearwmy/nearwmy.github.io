<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>兼容性问题记录</title>
      <link href="/2023/06/08/%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/06/08/%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Android-上底部样式有-absolute-fix-定位的时候，软键盘弹起时会顶起底部固定的-div"><a href="#1-Android-上底部样式有-absolute-fix-定位的时候，软键盘弹起时会顶起底部固定的-div" class="headerlink" title="1. Android 上底部样式有 absolute/fix 定位的时候，软键盘弹起时会顶起底部固定的 div"></a>1. Android 上底部样式有 absolute/fix 定位的时候，软键盘弹起时会顶起底部固定的 div</h3><p>部分 android 手机确实会这样，软键盘弹起直接改变了窗口的尺寸大小，所以底部按钮看起来就是被顶起来的样子。解决方案就是识别是 android 客户端，onresize 监听窗口尺寸发生变化时让底部 div 消失，收起时底部 div 出现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAndroid = <span class="regexp">/Android|Adr/i</span>.test(<span class="built_in">window</span>.navigator.userAgent);</span><br><span class="line"><span class="keyword">const</span> originalHeight = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isAndroid) &#123;</span><br><span class="line">    <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resizeHeight = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">        <span class="keyword">if</span> (resizeHeight &lt; originalHeight) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123; <span class="attr">showBottomBar</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123; <span class="attr">showBottomBar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-safari-中-input-输入框强制自带圆角边框"><a href="#2-safari-中-input-输入框强制自带圆角边框" class="headerlink" title="2. safari 中 input 输入框强制自带圆角边框"></a>2. safari 中 input 输入框强制自带圆角边框</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 0</span><br></pre></td></tr></table></figure><h3 id="3-safari-中-input-输入框-focus-时，页面会强制自动放大，并且失焦之后并不会缩回去。"><a href="#3-safari-中-input-输入框-focus-时，页面会强制自动放大，并且失焦之后并不会缩回去。" class="headerlink" title="3. safari 中 input 输入框 focus 时，页面会强制自动放大，并且失焦之后并不会缩回去。"></a>3. safari 中 input 输入框 focus 时，页面会强制自动放大，并且失焦之后并不会缩回去。</h3><p>这是因为 safari 和 android 在移动端自适应宽度上的处理方式不同导致的， safari 认为 focus 输入框时就应该让其放大，方便用户输入，但是失焦的时候，又不自动缩回去，不知道几个意思，导致咱们的 qa 认为这是个 bug。所以为了保持一致，需要把 safari 的这一行为禁用掉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止页面放大缩小的功能</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1, user-scalable=no"</span> /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="4-safari-中对-css：-webkit-mask-image-不支持，图片无法加载"><a href="#4-safari-中对-css：-webkit-mask-image-不支持，图片无法加载" class="headerlink" title="4. safari 中对 css： -webkit-mask-image 不支持，图片无法加载"></a>4. safari 中对 css： -webkit-mask-image 不支持，图片无法加载</h3><p> -webkit-mask-image 中的 url 在 safari 上加载时显示不出来，控制台有报错。可以使用 -webkit-mask-box-image 替换，亲测有效。</p><h3 id="5-Android-的不同机型-svg-element-getBoundingClientRect-获取的位置不一样-导致无法根据其返回的位置信息显示-UI"><a href="#5-Android-的不同机型-svg-element-getBoundingClientRect-获取的位置不一样-导致无法根据其返回的位置信息显示-UI" class="headerlink" title="5. Android 的不同机型 svg element.getBoundingClientRect  获取的位置不一样,导致无法根据其返回的位置信息显示 UI"></a>5. Android 的不同机型 svg element.getBoundingClientRect  获取的位置不一样,导致无法根据其返回的位置信息显示 UI</h3><p>我们的项目里 android 需要兼容到 android 5，chrome 的话最低兼容版本是 52， 而 android 上不同版本的 webview 内核不同的手机厂商下是不固定的，所以 chrome 的版本也是不固定的。</p><p>这个问题其实是 chrome 指定版本的问题，测试发现在 83 上会出现点击节点的时候通过getBoundingClientRect 获取的位置是被放大了，并且是根据 dpi 放大的，通过 caniuse 中确认 chrome 支持是没问题的，但是 issues 里面有相关的  Chromium issue #47998. 然而这个 bug 应该在 2013 年就被修复了，然后对比 chrome 的发布列表 83版本是2020年发布的，但是确实还是有问题，然后试了下 78 版本的也有这个问题。还是不知道为啥位置会不准，但是根据 dpi 缩小就可以了。所以目前的解决方案是判断 chrome 的版本，如果是在78-83区间的版本，获取的 x， y， top， left 相应属性值就会根据 dpi 缩小。</p><h3 id="6-移动端的点击穿透问题"><a href="#6-移动端的点击穿透问题" class="headerlink" title="6. 移动端的点击穿透问题"></a>6. 移动端的点击穿透问题</h3><p>移动端上支持响应 touch 和 click 事件，touch 事件总是先触发，大概 300ms 之后 click 会触发，click 事件触发之前，如果该绑定元素消失了，就会触发该元素下面的元素上。这种情况一般出现在弹窗和点击弹窗立马消失，弹窗下方又刚好有 click 原生事件的元素的情况下，一般是建议移动端点击事件全部使用 touch 代替 click，最好不要在一个元素上同时绑定 touch 和 click。如果出现这样的情况，可以在 touch 执行完毕的时候 e.preventDefault 可以解决。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件导入为什么会出现乱码</title>
      <link href="/2022/03/30/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81/"/>
      <url>/2022/03/30/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个导入文件并解析的需求，发现导入文件之后偶现乱码的问题。针对这个问题，小小的定位了一下。</p><h3 id="如何读取文件"><a href="#如何读取文件" class="headerlink" title="如何读取文件"></a>如何读取文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inputFileDom.addEventListener(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  fileReader.onload = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fileStr = info.target.result; <span class="comment">// 会出现乱码</span></span><br><span class="line">      doSomething(fileStr);</span><br><span class="line">  &#125;;</span><br><span class="line">  fileReader.readAsText(file);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>fileReader 的 read 相关操作，其实都还有第二个可选参数，就是字符编码类型，默认都是 UTF-8，如果说导入的文件出现了乱码，就说明编码格式不对，或者说文件缺少字符，导致编码识别错误，出现乱码。</p><h3 id="为什么会乱码"><a href="#为什么会乱码" class="headerlink" title="为什么会乱码"></a>为什么会乱码</h3><p>首先文件在计算机上的存储物理上其实都是二进制的，而文本文件和二进制文件只是逻辑上的区别，文本文件是基于字符编码的，常见的字符编码有 ASCII 编码，Unicode 编码等等，而二进制文件是基于值编码的文件。文本文件通常可以用文本编辑器打开，他们的区别就是编码不同。而文件的乱码通常都是因为编/解码格式不一样，所以出现了乱码。</p><p>前端中常见的就是文本文件的乱码，因为文本文件通常是可以预览的，二进制基本不能用文本编辑器或者输入框来预览。比如 html 文件在预览的时候为啥会出现乱码？ 因为文件在进行编码转换前，都会对文本文件的编码格式进行探测，常用的编码探测方法为根据文本文件对应的编码子节序标识，也就是文本的前几个字节进行判定，例如前三个字节为 EFBBBF，则为 UTF-8 编码格式；若前两个字节为 FEFF 则为 UTF-16BE 编码格式，若为 FFFE 则为 UTF-16LE 编码格式等。然而，这样的方法并不总是可行的，对于有些编码格式，例如 ASCII、GB2312 和 UTF7 编码等都没有编码字节序标识，对于这样的编码格式，通常采用给一个默认的编码格式进行编码转换，但默认的编码格式与文本文件的编码格式不一致则会使文本文件显示为乱码。</p><h3 id="如何解决乱码"><a href="#如何解决乱码" class="headerlink" title="如何解决乱码"></a>如何解决乱码</h3><p>可以读取文件的编码格式，然后在 read 相关操作的时候设置为该编码格式。这里读取文件的编码格式需要用到第三方包 <a href="https://www.npmjs.com/package/jschardet" target="_blank" rel="noopener">jschardet</a> : 读取数据的编码格式， <a href="https://www.npmjs.com/package/iconv-lite" target="_blank" rel="noopener">iconv-lite</a> 可以根据指定编码，解码数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">fileReader.onload = <span class="keyword">async</span> (event: any) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> buffer = Buffer.from(event.target.result);</span><br><span class="line">    <span class="keyword">const</span> type = jschardet.detect(buffer);</span><br><span class="line">    <span class="keyword">const</span> res = iconvlite.decode(buffer, type?.encoding || <span class="string">'utf-8'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fileReader.readAsArrayBuffer(info);</span><br></pre></td></tr></table></figure><p>注意： 以上的做法，只能说解决大部分乱码的问题，因为如果编码格式本身系统不支持或者浏览器不支持的话，该乱码的还是乱码。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 文件导入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 如何准确的获取文件的类型</title>
      <link href="/2022/03/30/js-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/30/js-%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h3><p>前端的小伙伴们应该很熟悉上传或者导入的场景，我也是最近在做一个导入文件的需求时，想通过前端准确的限制导入文件的类型，所以这里就延展出来一个需求：前端能怎样准确的获取文件的类型?</p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>先说说针对选择文件常见的前端处理有哪些：</p><h4 id="1-通过-input-file-标签的-accept-的属性来限制选择文件的默认类型"><a href="#1-通过-input-file-标签的-accept-的属性来限制选择文件的默认类型" class="headerlink" title="1.通过 input file 标签的 accept 的属性来限制选择文件的默认类型"></a>1.通过 input file 标签的 accept 的属性来限制选择文件的默认类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"file"</span> accept=<span class="string">"image/*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这个操作其实很简单，但是在实际操作中你会发现，在选择文件时，这个文件类型其实是可以切换为所有文件的，所以对于文件的限制，其实并没有起到太大作用。</p><h4 id="2-通过获取-File-对象的-type-字段来获取文件类型"><a href="#2-通过获取-File-对象的-type-字段来获取文件类型" class="headerlink" title="2.通过获取 File 对象的 type 字段来获取文件类型"></a>2.通过获取 File 对象的 type 字段来获取文件类型</h4><p>这里的 type 字段，是个只读字段。返回文件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">多用途互联网邮件扩展类型（MIME Type）</a></p><p>看看 File.type 的定义：</p><blockquote><p>字符串，包含媒体类型（MIME），表示文本是什么类型，例如 PNG 图像是 “image/png”。  </p></blockquote><p>但是这个属性并不是获取的文件的真正类型： </p><blockquote><p>注： 基于当前的实现，浏览器不会实际读取文件的字节流，来判断它的媒体类型。它基于文件扩展来假设；重命名为 .txt 的 PNG 图像文件为 “text/plain” 而不是 “image/png” 。而且，file.type 仅仅对常见文件类型可靠。例如图像、文档、音频和视频。不常见的文件扩展名会返回空字符串。开发者最好不要依靠这个属性，作为唯一的验证方案。</p></blockquote><p>这里说的问题在应用中我就遇到过，比如比较常见的 .md， .opml 就没有 type 字段，通过 type 字段判断所有类型是不靠谱的，如果只是一些常见的图像类型还是可以的。</p><p>另外，type 字段的兼容性问题：</p><p><img src="/images/fileType.png" alt="fileType"></p><h4 id="3-获取文件名的后缀"><a href="#3-获取文件名的后缀" class="headerlink" title="3.获取文件名的后缀"></a>3.获取文件名的后缀</h4><p>这个方式也比较普遍，通过剪切获取后缀名来判断文件类型，这个其实更不靠谱，因为文件名是可以修改的。</p><p>总结以上的获取文件类型的方法，优点是简单快捷，缺点就是都不能百分之百保证能准确的获取到文件的真实类型。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法?"></a>其他方法?</h3><p>想到如何获取文件的类型，其实就想每个文件在电脑里面又是怎么区分的了，既然他们能区分，那肯定就有获取类型的方法。另外一个就是文件如果要存储文件类型的话，他能存在哪里，文件一般都是裸奔，估计只有文件本身里面能存储了吧，类比图片信息。所以这里还有一种获取文件类型的方式，就是解读文件信息，一般文件头部字段里面会标识当前文件的类型。</p><h3 id="获取文件签名"><a href="#获取文件签名" class="headerlink" title="获取文件签名"></a>获取文件签名</h3><p>web API 里面的 FileReader 可以读取文件信息，先读取文件的 buffer 类型数据 ，然后通过 DataView 转化为可查看或者操作的对象，根据不同文件类型独一无二的文件签名 file signature，然后根据 <a href="https://en.wikipedia.org/wiki/List_of_file_signatures" target="_blank" rel="noopener">List of file signatures</a> 或者 <a href="http://filesignatures.net/index.php?page=all" target="_blank" rel="noopener">filesignatures</a> 确定文件类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fileDom.addEventListener(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> file = event.target.files[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fileReader.onload = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(event.target.result);</span><br><span class="line">       handleFileType(view);</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.readAsArrayBuffer(file);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFileType = <span class="function">(<span class="params">view</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> first4Bytes = view.getUint32(<span class="number">0</span>, <span class="literal">false</span>); </span><br><span class="line">  <span class="keyword">let</span> first4BytesHex = <span class="built_in">Number</span>(first4Bytes).toString(<span class="number">16</span>).toUpperCase(); <span class="comment">// 文件签名的16进制 eg： png -&gt; 89504E47</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 根据文件签名白名单获取具体的文件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>这里可以使用 Typed Array 或者 DataView 将 ArrayBuffer 转化成可以查看、操作的对象，为啥不用 Typed Array，是因为不同平台存在不同的字节序的问题，具体可查看： <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Endianness" target="_blank" rel="noopener">字节序</a></li><li>此方法其实也并不是特别完美，并且使用此方法需要读取文件。</li></ol><h3 id="还是不行？"><a href="#还是不行？" class="headerlink" title="还是不行？"></a>还是不行？</h3><p>通过上面的方法貌似可以确定文件类型，但是实际经验告诉我并没有，发现文件签名里面的类型没有 html， md， csv， txt， 这种。这里就需要搞清楚为啥没有这些文件类型？</p><p>这里就要说到文件类型的表示方法，有上面 accept 或者 type 字段的格式，也就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">MIME 类型</a>, 格式就是 <code>type/subtype</code>。还有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#%E5%85%B6%E4%BB%96%E4%BC%A0%E9%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">其他传送文件类型</a> 的方法，就是：</p><blockquote><p>MIME 类型不是传达文档类型信息的唯一方式：<br>有时会使用名称后缀，特别是在 Microsoft Windows 系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是 Linux 和 Mac OS），并且像外部 MIME 类型一样，不能保证它们是正确的。<br>魔术数字。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个 GIF 文件以 47 49 46 38 十六进制值 [GIF89] 或 89 50 4E 47 [.PNG] 的 PNG 文件开头。并非所有类型的文件都有幻数，所以这也不是 100％可靠的方式。</p></blockquote><p>上面提到的文件签名的方法应该是 <strong>魔术数字</strong> 。但是不是所有类型的文件都有幻数。那为什么有些文件没有幻数呢，因为文件其实分两种大类：文本文件和二进制文件。基于二进制格式的文件就会有幻数，但是基于文本的就没有，而 html csv txt 这种就都属于基于文本格式的文件类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从以上信息可以看出，其实每个方法都不算太完美的解决此问题，所以针对获取文件类型的判断可以分场景结合多种方法来判断，先是 file.type 字段或者文件后缀名，如果有值可以根据此判断，如果值为空则继续通过读取文件签名的方式判断。并且在读取大文件的时候，要优化好用户体验。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM to Image 的原理解析</title>
      <link href="/2022/01/25/DOM-to-Image-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/01/25/DOM-to-Image-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>在工作中遇到一个项目，需要当前视图可以导出为图片，目前前端的解决方案的话，就是要对当前 dom 进行截图处理。针对此解决方案的两个工具就是 html2canvas 和这里的 DOM to Image，这里就是将对 DOM to Image 这个包的使用方法和原理做一些说明。</p><p><a href="https://github.com/tsayen/dom-to-image" target="_blank" rel="noopener">dom-to-image</a></p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ES6</span></span><br><span class="line"><span class="keyword">import</span> domtoimage <span class="keyword">from</span> <span class="string">'dom-to-image'</span>;</span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'my-node'</span>);</span><br><span class="line">domtoimage.toPng(node)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">dataUrl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        img.src = dataUrl;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(img);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'oops, something went wrong!'</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>核心原理：该库使用 SVG 的一项功能，允许在 <code>&lt;foreignObject&gt;</code> 标记内包含任意 HTML 内容。</p><p>具体步骤：</p><ol><li>递归克隆节点<br>a. 复制节点或者子节点<br>b. 复制节点的计算样式，伪类元素到克隆节点<br>c. 复制用户输入区域内容，textarea 或者 input 区域的值<br>d. 复制 svg 标签元素等</li><li>枚举获取网页的 @font-face，并通过 style 标签增加到克隆节点中</li><li>解析 image urls ，远程链接下载并通过 fileReader 转换成 dataurl</li><li>处理所有 css 行内规则并通过 <code>&lt;style&gt;</code> 标签添加</li><li>将所有 html 代码转换为 xml，并封装到  <code>&lt;foreignObject&gt;</code> 标签中 ，然后封装到 svg 中</li><li>转换为 png， jpge 则是基于 toSvg 的结果，通过 image load 读出图片信息放入 canvas 渲染图片，导出 dataUrl</li><li>转换 blob 则是根据 canvas 转的 blob 对象</li><li>转换为图片像素信息则是根据 canvas.getImageData  </li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>如果无法兼容 svg 的阴影 drop-shadow， 导致导出的图片有问题</li><li>dom-to-image 在chrome 上表现良好，性能最优，可能是因为 chrome 对 svg 支持的更好，ie 上不支持 svg 的  <code>&lt;foreignObject&gt;</code>， safari 上对此标签的支持具有更严格的安全模型，建议在safari 上使用时通过 toSvg 并在服务器上呈现。</li><li>跟 html2canvas 相比，这个库只有 770 行代码，更轻量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端base64知识</title>
      <link href="/2021/11/02/%E5%89%8D%E7%AB%AFbase64%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/11/02/%E5%89%8D%E7%AB%AFbase64%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>前段时间，有涉及到相关方面的业务，想来这个天天挂在嘴边的东西我到底知道他多少，今天就打算在这里整理一下。</p><pre><code>随着工作年限越来越长，发现每遇到一个问题就喜欢把这一类的问题都搞明白，我觉得这是个好习惯。</code></pre><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先说下 base64 为什么要叫这个名字呢？ 为什么是 64 不是 46 或者 60 之类的，好像以前从来就没有考虑过这个问题。<br>base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法，可打印字符包括字母 A-Z a-z 数字 0-9，另加 + / 两个字符，所以一共是 64 个字符，常用于在通常处理文本数据的场合表示， 传输，存储一些二进制数据，包括 MIME的电子邮件及XML的一些复杂数据。</p><p><img src="/images/base64.png" alt="base64"></p><h3 id="Base64-在前端的应用"><a href="#Base64-在前端的应用" class="headerlink" title="Base64 在前端的应用"></a>Base64 在前端的应用</h3><p>Base64 编码， 在前端的常见应用有 toDataURLs, 小图片展示</p><h4 id="canvas-转图片"><a href="#canvas-转图片" class="headerlink" title="canvas 转图片"></a>canvas 转图片</h4><p>canvas 的 toDataURL 可以把 canvas 的画布内容转 base64 编码格式。通常使用在 你画我猜 新用户加入 要获取当前的最新的绘画界面，也可以通过 base64 格式的消息传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = canvasEl.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="keyword">const</span> dataUrl = canvasEl.toDataURL();</span><br></pre></td></tr></table></figure><h4 id="FileReader-文件读取"><a href="#FileReader-文件读取" class="headerlink" title="FileReader 文件读取"></a>FileReader 文件读取</h4><p>可以通过 readAsDataURL 将本地文件转换成 base64 格式的 data URI，比较常见的就是用户头像的裁剪和上传。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="built_in">document</span>.getElementById(<span class="string">'inputFile'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fd = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fd.readAsDataURL(fileEl.files[<span class="number">0</span>]);</span><br><span class="line">    fd.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(fd.result);</span><br><span class="line">    &#125;;</span><br><span class="line">    fd.onerror = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网站图片"><a href="#网站图片" class="headerlink" title="网站图片"></a>网站图片</h4><p>比如 img 标签展示 src 可以是 base64 格式的图片，background-image 也是一样。</p><h4 id="简单的数据加密"><a href="#简单的数据加密" class="headerlink" title="简单的数据加密"></a>简单的数据加密</h4><p>只是为了让你不好解读，安全性不太高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</span><br><span class="line"><span class="keyword">const</span> password = <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).value;</span><br><span class="line"><span class="keyword">const</span> secureKey = <span class="string">"%%S$%DS)_SDSDJ_66"</span>;</span><br><span class="line"><span class="keyword">const</span> sPass = utf8_to_base64(password+ secureKey);</span><br><span class="line"></span><br><span class="line">doLogin(&#123;</span><br><span class="line">  username,</span><br><span class="line">  password: sPass</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>X.509 公钥证书， github SSH key ，mht 文件，邮件附件，混淆加密， sourceMapping 等等</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><pre><code>1. 可以对二进制数据转化为可打印的字符，方便传输数据2. 对数据进行简单的加密，肉眼是安全的3. 如果是在 html 或者 css 树立图片，可以减少 http 请求</code></pre><p>缺点</p><pre><code>1. 内容编码之后体积变大，至少 1/3，因为是三字节变成四字节，当只有一个字节的时候，也至少会变成三个字节2. 编码和解码需要额外工作量。</code></pre>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首-2020</title>
      <link href="/2021/04/18/%E5%9B%9E%E9%A6%96-2020/"/>
      <url>/2021/04/18/%E5%9B%9E%E9%A6%96-2020/</url>
      
        <content type="html"><![CDATA[<p>不知不觉养成了每年回首总结的习惯，也算是对自己的周期性自省。每次的总结都是有感而发，今年的总结感觉来的稍晚一些，不光是因为懒，也和那个特殊的2020有一定的关系。</p><p>去年爆发了新冠疫情，从大年初三开始，武汉实行了封城，整个中国也开始进行封路封村，禁止大摆酒席的这样一个状态。而我，害怕耽误工作，选择了初五坐飞机赶回北京出租房。我走后的第二天，我们市就也实行了高速路封闭的政策，幸好我提前离开了。</p><p>回到北京，政府也不允许全面复工，先是14天的居家隔离，然后公司实行轮流上班制度。因为我们部门是做办公软件的，所以在疫情期间，客户量在短时间内高速增长，而我负责的管理后台，也是面临数据量大的挑战，每天虽然在家隔离，但是上班的时间反而变多了。有时候中午都是在边吃饭边开会，晚上12点也还在开会讨论短期解决方案。那段时间，在北京的街头几乎没什么人，春节期间好像还下了几场大雪，更是人烟稀少，所幸盒马鲜生还没停，每天都是自己点菜做饭上班睡觉，还假吧意思的减个肥。</p><p>由于2019年底就下定决心来年回成都，所以我选择了短租一个房子，也是为了给自己不留后路，疫情之后又是在家上班，认识了隔壁的小姐姐，还挺聊得来的，互相做饭，一起吃火锅，好歹还不孤单，回想起来，真的是缘分啊，在那段特殊的时期里，互相陪伴，我们在家煮了好多顿火锅，然后喝酒聊天。现在也在保持联系。那段隔离的日子除了这些快乐，更多的是工作的压力，自己一个人在特殊时期背井离乡的那种孤独，那段时间更坚定了我回成都的想法。</p><h4 id="2020年的第一个重大决定"><a href="#2020年的第一个重大决定" class="headerlink" title="2020年的第一个重大决定"></a>2020年的第一个重大决定</h4><p>4月份吧，等着把年终奖发了，就提了离职，其实挺不舍得，但是比较了一下孰轻孰重，可能当时的我，更希望回到成都，改变一下自己的现状。所以跟公司几番交涉之后，选择了平薪调岗回成都分公司，对于这个结果，我是没有想到过，当得知这一消息时，我很开心，还马上告诉了我爸妈，我可以不裸辞回成都拉，全家都非常高兴。记得那个时候也是有感而发了一些长篇大论，感恩生活，感恩自己，甚至感恩公司领导。</p><p>因为回成都，所以我需要在北京磨合下新部门，呆了一个多月的时间，就回了成都。记得走出机场的那晚，天下着毛毛雨，明显能感受到空气的湿润，打车回家的司机是个女师傅，车技了得，一路行云流水的穿梭在成都街头，而我也慢慢的认识着这个阔别3年多的成都。每次飞机落地双流机场，我都无比心安，本以为我是个没什么家乡情结的人，在北京呆了几年后，我发现还是回到熟悉的城市确实让人无比心安，突然就想到那句话： 心安即是归处。</p><p>回成都之后，给自己请了一周的假，回趟老家和找房子，然后开始了成都的上班生活。不管是回成都，还是辞职，其实我最想做的是改变自己的现状，工作的话算是进入了一个舒适圈，所以我想挑战下自己，是换新环境也好，还是换部门，我就是想再折腾下。然后回到成都的生工作并非我想的那样，这里面有我自己的原因，也有领导的原因。记得8月份那段时间，一度讨厌上班，感觉自己就像个行尸走肉，我一直觉得如果你开始讨厌这份工作，那么你离辞职就不远了。为了调整自己，我选择了休年假，然而因为年假，或者不是年假的原因，领导可能觉得鞭长莫及，明确要求我休假完当天回北京复命。那时我就给自己做好了今年的第二个决定。</p><h4 id="2020年的第二个重大决定"><a href="#2020年的第二个重大决定" class="headerlink" title="2020年的第二个重大决定"></a>2020年的第二个重大决定</h4><p>回到北京之后，我提出了辞职，领导试图探索我离职的真实原因，但是自从上次和领导交涉离职我就发现，以前是我太单纯，把他当作了良师一般的角色，比较尊敬他，所以愿意向他吐露一些真实想法。但是我发现，其实他并不关心对公司和对业务线的建议，他在乎的可能更多的是如何管理好手下的团队，他始终是领导的一个角色，而非良师。当然，我也很感谢他有时说出的一些话，对我来说受益匪浅。只能说 道不同不相为谋。也很感谢刚进公司时带我的小姐姐，最后离职的时候，我们也是一起吃了个饭，现在的她已经完成了蜕变，成了一个团队的 leader，恭喜她。</p><p>现在回想起来，裸辞这个决定我承认有点冲动，虽然最后马上找到了下一份工作，但是团队和之前比起来，差的有点多。那时我才意识到，其实我对成都的公司了解太少，而我脱离了原来的团队，我能做多少？这个问题，好像我裸辞的时候并没有想清楚。</p><h4 id="突然的断粮"><a href="#突然的断粮" class="headerlink" title="突然的断粮"></a>突然的断粮</h4><p>我的下家，在年前最后一天，把我们裁员了。对于从未经历过裁员的我，也是当头一棒。虽然这家公司，我来的第三天就想走了，但是为了钱，我选择留下，并期望通过自己的主动争取，获取一些新项目的锻炼机会来提升自己。后来发现，我还是太年轻，没看清局势，这家公司并没有能力支撑这些，所以为了控制成本吧，新来的同学们就被 正式薪资的 80% 的 n+1 赔偿 给裁员了，这个 n+1 还是我们抱团和公司据理力争争取来的，也是一把辛酸一把泪。</p><p>所以在2020年底，我再次成了一个失业人员。</p><p>经过这么一遭，我才发现我想找的并不是一份新工作，而是一个新的良好的环境，有活力的团队。并且我发现在3-5年这个经验找工作并且是一名女生，自身和公司考虑的东西都会比刚毕业时多好多。这个时候的我应该更注重稳定性和福利，制度，当然最重要的是自己喜欢涉及的主方向和能够有所沉淀的复杂丰富的项目经验。</p><p>所以先回家过个好年，来年再战。</p><p>哦，对了，回成都之后，家里的亲戚也是紧锣密鼓的帮我张罗相亲，我并不排斥相亲，我觉得这只是一种渠道而已，最终还是要看两个人是否合适，终于在不懈努力下，我成功脱单了。这也算是2020年的第二件值得高兴的事情，所以生活吧，我觉得只要你还有积极乐观的生活态度，就不停折腾吧，越折腾你就越了解自己，越了解自己才会活得越自在，将你擅长的地方用到极致。</p><h4 id="总结性发言"><a href="#总结性发言" class="headerlink" title="总结性发言"></a>总结性发言</h4><p>千万不要缩在自己的舒适圈里，当你被迫出来的时候，可能你已经心有余而力不足了。<br>生活，还是要把主动权掌握在自己手里的好。</p><p>无论是主动离职，还是被裁员，我觉得这都是我选择的结果，我必须承担它带来的后果，而且经过这么一遭，我更了解了自己找工作的真实需求，并不后悔。<br>福兮祸所依，祸兮福所伏<br>只要你有积极乐观的生活态度和对工作的热爱，和自信，一切都会向自己努力的方向发展的</p><p>共勉～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 基础面试题总结</title>
      <link href="/2021/04/14/js%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/04/14/js%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<!-- [值传递和值引用](#value)[对 this 对象的理解](#this)[隐式转换](#transform)[事件循环， 宏任务，微任务](#eventLoop)[提升（hoisting）](#hoisting)[作用域](#scope)[正则表达式](#reg)[object 的 key值的类型转换](#keys)[js 原生方法](#methods) --><h3 id="value"> 值传递和值引用 </h3><p>js 数据类型分为 基本类型和引用类型</p><p>基本类型： Number Boolean String Undefined Null Symbol<br>引用类型： Object Function Array Date RegExp Math 其他类 object 的实例对象</p><p>基本类型的存储方式： 变量和值都在栈内存中<br>引用类型的存储方式： 变量名存储在栈内存中，值存储在堆内存中，堆内存中会提供一个引用地址指向堆内存中的值，而这个引用地址是储存在栈内存中的。</p><ol><li><p>打印以下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function changeObjProperty(o) &#123;</span><br><span class="line">  o.siteUrl = &quot;http://www.baidu.com&quot;</span><br><span class="line">  o = new Object()</span><br><span class="line">  o.siteUrl = &quot;http://www.google.com&quot;</span><br><span class="line">&#125; </span><br><span class="line">let webSite = new Object();</span><br><span class="line">changeObjProperty(webSite);</span><br><span class="line">console.log(webSite.siteUrl);</span><br><span class="line">&lt;!-- 原因：changeObjProperty 的参数是变量的引用, new Object 是创建了一个新对象，对外面的 webSite 不产生影响 --&gt;</span><br></pre></td></tr></table></figure></li><li><p>检查对象类型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. typeof </span><br><span class="line">2. instanceof</span><br><span class="line">3. Object.prototype.toString.call(args) // 可检查所有对象类型</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>深拷贝 &amp; 浅拷贝  </p><pre><code>这里的拷贝要区别于赋值操作， 对基本类型数据的赋值操作是值传递，对引用类型的数据的赋值操作是引用传递，而浅拷贝是新创建了对象，对第一层数据进行复制，子对象的话则是引用传递</code></pre><p> 浅拷贝：创建新对象，对第一层属性进行赋值，子对象的话依然是引用传递<br> 深拷贝：创建新对象，对对象和子对象进行完全的复制，被拷贝对象发生任何变化不会影响到新对象</p><p>举例说明赋值和浅拷贝的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;near&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">  language: &#123;</span><br><span class="line">    value: &apos;zh&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = obj</span><br><span class="line">var obj3 = copy(obj)</span><br><span class="line"></span><br><span class="line">// 浅拷贝</span><br><span class="line">function copy(obj) &#123;</span><br><span class="line">  let newObj = &#123;&#125;</span><br><span class="line">  for(let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name = &apos;Lisa&apos;</span><br><span class="line">console.log(obj2.name) // &apos;Lisa&apos; 值引用，指向同一块内存地址，所以会同步改变</span><br><span class="line">console.log(obj3.name) // &apos;near&apos; 第一层基本数据类型是值传递</span><br><span class="line"></span><br><span class="line">obj.language.value = &apos;en&apos;</span><br><span class="line">console.log(obj2.language.value) // &apos;en&apos; 子对象是值引用，所以会互相影响</span><br><span class="line">console.log(obj3.language.value) // &apos;en&apos;</span><br></pre></td></tr></table></figure></li></ol><h5>常见的浅拷贝</h5><ol><li><p>直接赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 2 &#125;</span><br><span class="line">let obj2 = obj</span><br><span class="line">obj2.a = 1</span><br><span class="line">obj.a // 1</span><br></pre></td></tr></table></figure></li><li><p>对象解构 </p></li><li>for in 循环赋值</li><li><p>ES6 的 Object.assign</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 20, b: &#123; c: 3 &#125; &#125;</span><br><span class="line">let obj2 = Object.assign(&#123;&#125;, obj)</span><br><span class="line">obj2.a = 10</span><br><span class="line">obj.a // 20</span><br><span class="line">obj2.b.c = 10 </span><br><span class="line">obj.b.c // 10</span><br></pre></td></tr></table></figure></li></ol><h5>常见的深拷贝</h5><ol><li><p>JSON.parse(JSON.stringify())</p><p>对象属性比较简单的时候可以使用，此方法会出现的问题有：</p><ol><li>值为 undefined 的属性转换后会丢失</li><li>值为 Symbol 类型的属性在转换后丢失</li><li>值为 RegExp 对象的属性在转换后变成了空对象</li><li>值为 函数对象的属性在转换后丢失</li><li>值为 Date 对象的属性在转换后变成了字符串</li><li>会抛弃对象的 constructor,所有的构造函数会指向 Object</li><li>对象的循环引用会抛出错误。</li></ol></li><li><p>手动实现 deepClone</p><p>解决问题：  </p><ol><li>循环引用过多导致爆栈  </li><li>特殊值拷贝属性丢失</li><li>会抛弃对象的 constructor,所有的构造函数会指向 Object  </li></ol></li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 特殊值过滤掉 typeof null === &apos;object&apos;  原生构造函数 --&gt;</span><br><span class="line"></span><br><span class="line">    if (obj === null) return obj</span><br><span class="line">    if (obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">    if (obj instanceof Date) return new Date(obj)</span><br><span class="line">    if (typeof obj !== &apos;object&apos;) return obj</span><br><span class="line"></span><br><span class="line">    &lt;!-- 避免循环引用爆栈 --&gt;</span><br><span class="line"></span><br><span class="line">    if (hash.has(obj)) return hash.get(obj)</span><br><span class="line">    </span><br><span class="line">    &lt;!-- constructor 属性理论上来说不太可靠，此属性可以被修改，但是在复制场景下 不太会被修改 --&gt;</span><br><span class="line"></span><br><span class="line">    let newObj = new obj.constructor</span><br><span class="line"></span><br><span class="line">    hash.set(obj, newObj)</span><br><span class="line"></span><br><span class="line">    &lt;!-- symbol 的 key 是不可枚举的类型，所以 hasOwnProperty 无法遍历出来，需要单独通过 getOwnPropertySymbols 解决 --&gt;</span><br><span class="line"></span><br><span class="line">    let symKeys = Object.getOwnPropertySymbols(obj)</span><br><span class="line">    if (symKeys.length) &#123;</span><br><span class="line">      symKeys.forEach(item =&gt; &#123;</span><br><span class="line">        newObj[item] = deepClone(obj[item], hash)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 只拷贝对象的值，不拷贝原型链上的值 --&gt;</span><br><span class="line"></span><br><span class="line">    for (const key in obj) &#123;</span><br><span class="line">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        newObj[key] = deepClone(obj[key], hash)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newObj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="this">对 this 对象的理解</h3><p>关于 this 的一些关键性理解：</p><ol><li>this 总是指向函数的直接调用者</li><li>如果有 new 关键字，this 指向 new 出来的实例对象</li><li>在事件中，this 指向触发这个事件的对象</li><li>IE 下 attachEvent 中的 this 总是指向全局对象 Window</li><li>箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象。</li><li>箭头函数里的 this 如果放在全局中就是 window </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 1</span><br><span class="line">foo()           //1  </span><br><span class="line">​</span><br><span class="line">const obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()      //2</span><br><span class="line">​</span><br><span class="line">const c = new foo()  // undefined</span><br><span class="line">  </span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: () =&gt; &#123;</span><br><span class="line">    console.log(this.a)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 箭头函数本身没有 this，只取决于包裹箭头函数的第一个普通函数的 this 。 此时是存在于obj，也就是window中，所以 this = window --&gt;</span><br><span class="line">obj2.foo() // 1 </span><br><span class="line"></span><br><span class="line">// this 指向被调用的函数的作用域</span><br><span class="line">var name = &quot;caibaojian.com&quot;; </span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;kang&quot;,</span><br><span class="line">    pro: &#123;</span><br><span class="line">        name: &quot;Michael&quot;,</span><br><span class="line">        getName: function() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(person.pro.getName()); //Michael</span><br><span class="line">var people = person.pro.getName; // 此时调用函数的this 指向 window</span><br><span class="line">console.log(people()); //caibaojian.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">var name = &quot;caibaojian.com&quot;; </span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;kang&quot;,</span><br><span class="line">    pro: &#123;</span><br><span class="line">        name: &quot;Michael&quot;,</span><br><span class="line">        getName: function() &#123;</span><br><span class="line">            console.log(this);</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(person.pro.getName()); //Michael</span><br><span class="line">var people = person.pro.getName;</span><br><span class="line">console.log(people()); //undefined 在严格模式下，如果this未被执行的上下文环境定义，那么它将会默认为undefined。</span><br><span class="line"></span><br><span class="line">// 普通函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line">foo.call(&#123; id: 42 &#125;); //21</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line">foo.call(&#123; id: 42 &#125;); // 42，箭头函数中的 this 和执行的函数内部的this保持一致，此时通过 call 方法指向了 &#123;id: 42&#125; 所以此时输出 42</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line">foo.call(); // 21</span><br></pre></td></tr></table></figure><ol><li><p>手动实现 bind 函数。  </p><pre><code>bind 做了什么：  1. 将 this 绑定到当前函数参数中2. 不立即执行，返回一个函数3. 函数参数原型上的方法还能执行4. this 不能在绑定到其他变量上面5. 待执行函数还可以传递其他参数</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(obj) &#123;</span><br><span class="line">  let args = [].slice.call(arguments, 1)</span><br><span class="line">  var fn = this</span><br><span class="line">  var bound = function() &#123;</span><br><span class="line">    var argguments = Array.from(argguments)</span><br><span class="line">    fn.apply(this.constructor === fn ? this : obj, args.concat(argguments))</span><br><span class="line">  &#125;</span><br><span class="line">  bound.prototype = fn.prototype</span><br><span class="line">  return bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li>手动实现 call / apply 函数</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 简单实现 call --&gt;</span><br><span class="line"></span><br><span class="line">Function.prototype.call_ = function (obj) &#123;</span><br><span class="line">    obj.fn = this; // 此时this就是函数fn</span><br><span class="line">    obj.fn(); // 执行fn</span><br><span class="line">    delete obj.fn; //删除fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;!-- ES5 call --&gt;</span><br><span class="line">Object.prototype.call = function(obj) &#123;</span><br><span class="line">    //判断是否为null或者undefined,同时考虑传递参数不是对象情况</span><br><span class="line">    obj = obj ? Object(obj) : window;</span><br><span class="line">    var args = [];</span><br><span class="line">    // 注意i从1开始</span><br><span class="line">    for (var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&quot;arguments[&quot; + i + &quot;]&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = this; // 此时this就是函数fn</span><br><span class="line">    eval(&quot;obj.fn(&quot; + args + &quot;)&quot;); // 执行fn</span><br><span class="line">    delete obj.fn; //删除fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6 call</span><br><span class="line">Function.prototype.call_ = function (obj) &#123;</span><br><span class="line">    obj = obj ? Object(obj) : window;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    // 利用拓展运算符直接将arguments转为数组</span><br><span class="line">    let args = [...arguments].slice(1);</span><br><span class="line">    let result = obj.fn(...args);</span><br><span class="line"></span><br><span class="line">    delete obj.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ES5 apply</span><br><span class="line">Function.prototype.apply_ = function (obj, arr) &#123;</span><br><span class="line">    obj = obj ? Object(obj) : window;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = obj.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        // 注意这里的i从0开始</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        result = eval(&quot;obj.fn(&quot; + args + &quot;)&quot;); // 执行fn</span><br><span class="line">    &#125;;</span><br><span class="line">    delete obj.fn; //删除fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES6 apply</span><br><span class="line">Function.prototype.apply_ = function (obj, arr) &#123;</span><br><span class="line">    obj = obj ? Object(obj) : window;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    let result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = obj.fn();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = obj.fn(...arr);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    delete obj.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="transform">隐式转换</h3><p>隐式转换规则：  </p><ol><li>undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。</li><li>String == Boolean，需要两个操作数同时转为Number。</li><li>String/Boolean == Number，需要String/Boolean转为Number。</li><li>Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">var b = [1, 2, 3];</span><br><span class="line">var c = &quot;1,2,3&quot;;</span><br><span class="line"></span><br><span class="line">a == c; // true</span><br><span class="line">b == c; // true 数组和字符串比较时，数组会通过逗号拼接转换为字符串</span><br><span class="line">a == b; // false 两个相同数组不相等</span><br><span class="line"></span><br><span class="line">思考题：</span><br><span class="line">++[[]][+[]]+[+[]]==10 // true</span><br><span class="line"></span><br><span class="line">// (++[[]][+[]]) + ([+[]])</span><br><span class="line">// +[] = 0  </span><br><span class="line">// (++[[]][0]) + [0]</span><br><span class="line">// var a = [[]][0]; ++a;</span><br><span class="line">// var a = []; a = a+1; ++[] = 1</span><br><span class="line">// 1 + [0]  // [0] == &apos;0&apos;</span><br><span class="line">// &apos;10&apos;</span><br><span class="line"></span><br><span class="line">valueOf 和 toString()</span><br></pre></td></tr></table></figure><h3 id="eventLoop">事件循环， 宏任务，微任务</h3><ol><li><p>打印一下结果 事件循环和异步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>事件循环和异步</p><p> 微任务：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">// setTimeout 和 promise</span><br><span class="line">const tasks = []</span><br><span class="line">const output = (i) =&gt; new Promise((reslove) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">reslove();</span><br><span class="line">&#125;, 1000 * i)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for(var i = 0; i&lt;5; i++) &#123;</span><br><span class="line">tasks.push(output(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all(tasks).then(() =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 0 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">// setTimout 和 sleep</span><br><span class="line">setTimeout(() =&gt; &#123; console.log(1) &#125;, 1000)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123; console.log(2) &#125;, 0)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">    setTimeout(() =&gt; &#123; console.log(4) &#125;, 0)</span><br><span class="line"> &#125;, 800)</span><br><span class="line">function sleep(delay) &#123;</span><br><span class="line">    var start = (new Date()).getTime();</span><br><span class="line">    while((new Date()).getTime() - start &lt; delay) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(1200)</span><br><span class="line">console.log(5)</span><br><span class="line">for(var i=10;i&lt;=15;i++) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;console.log(i)&#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5 2 3 1 16*6  4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// setTimeout process.nextTick promise</span><br><span class="line">console.log(&apos;1&apos;);</span><br><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;3&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;5&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;7&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;8&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;9&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;10&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;11&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;12&apos;);</span><br><span class="line"></span><br><span class="line">// 1 2 4 10 12 5 （3 11） 6 8 7 9 </span><br><span class="line"></span><br><span class="line">// 宏任务 和 微任务的创建时机</span><br><span class="line"></span><br><span class="line">console.log(&apos;start&apos;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;children2&apos;);</span><br><span class="line">    Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;children3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve, reject) &#123;</span><br><span class="line">    console.log(&apos;children4&apos;);</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;children5&apos;);</span><br><span class="line">        resolve(&apos;children6&apos;)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(&apos;children7&apos;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">// 执行结果</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">children4</span><br><span class="line">children2</span><br><span class="line">children3</span><br><span class="line">children5</span><br><span class="line">children7</span><br><span class="line">children6</span><br><span class="line"></span><br><span class="line">// 说明：在没有 reslove 的时候，不会将 then 创建为微任务</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">const p = function() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                resolve(1)</span><br><span class="line">            &#125;, 0)</span><br><span class="line">            resolve(2)</span><br><span class="line">        &#125;)</span><br><span class="line">        p1.then((res) =&gt; &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">        console.log(3);</span><br><span class="line">        resolve(4);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p().then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;);</span><br><span class="line"></span><br><span class="line">// 从上向下执行，p1.then 先进入微任务队列，p.then 后进入，所以结果为：</span><br><span class="line">// 3 ‘end’ 2 4</span><br></pre></td></tr></table></figure></li></ol><h3 id="hoisting">提升（hoisting）</h3><ol><li>var 声明会提升</li><li>函数声明会首先提升，但是函数表达式不会提升声明</li><li>声明统一提前，赋值原地不变</li><li>提升变量阶段： var 是提升声明，还没有被定义； 函数关键字的就已经声明和定义  </li><li><p>条件判断语句，没有大括号时，if 条件不满足，则最近的一条语句不执行，if 满足，则后面的条件都会走； 有大括号时，不满足时外部条件都执行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">var a</span><br><span class="line">console.log(a) // 2</span><br><span class="line"></span><br><span class="line">console.log(a) // undefined</span><br><span class="line">var a = 2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function A() &#123; console.log(2) &#125;</span><br><span class="line">var A = function() &#123; console.log(1) &#125;</span><br><span class="line">A()</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">var A = function() &#123; console.log(1) &#125;</span><br><span class="line">function A() &#123; console.log(2) &#125;</span><br><span class="line">A()</span><br><span class="line">// 1 此时 A 已经在window 属性下，这属于重名，根据js自上而下执行，此时再次声明会被忽略</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line">var A = function() &#123; console.log(1) &#125;</span><br><span class="line">function A() &#123; console.log(2) &#125;</span><br><span class="line">// 2 函数声明会首先被提升，所以输出 2</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line">function A() &#123; console.log(2) &#125;</span><br><span class="line">var A = function() &#123; console.log(1) &#125;</span><br><span class="line">function A() &#123; console.log(3) &#125;</span><br><span class="line">// 3 重复的函数声明还是可以覆盖前面的,函数表达式不会声明提前</span><br><span class="line"></span><br><span class="line">if(true) &#123; function B() &#123; console.log(1) &#125; &#125;</span><br><span class="line">&#123; var B = function() &#123; console.log(2) &#125;  &#125;</span><br><span class="line">B()</span><br><span class="line">// 2  函数声明之后，函数表达式可以改变函数； </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(a, b) // undefined undefined 执行时都未定义 所以输出 undefined</span><br><span class="line">var a =12, b =&apos;林一一&apos; // window.b = &apos;林一一&apos;</span><br><span class="line">function foo()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(a, b) // 此时 b 不带 var 将向上级作用域查找， a 因为函数内部 var 变量提升 为 undefined</span><br><span class="line"></span><br><span class="line">    var a = b =13</span><br><span class="line">    console.log(a, b) // 13 13 window.b = 13， a 此时为函数内部变量</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(a, b) // 12 13 此时读取全局变量 a = 12， window.b 有foo 改变，所以为 13</span><br><span class="line"></span><br><span class="line">// undefined undefined</span><br><span class="line">// undefined 林--</span><br><span class="line">// 13 13</span><br><span class="line">// 12 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = 0</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var a =12;</span><br><span class="line">    b = &apos;林一一&apos;</span><br><span class="line">    console.log(&apos;b&apos; in window) // b 没有声明 因此向上级作用域查找 true</span><br><span class="line">    console.log(a, b) // 12 &apos;林一一&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">console.log(b) // window.b = &apos;林一一&apos;</span><br><span class="line">console.log(a) // window.a = 0 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">    a =12;</span><br><span class="line">    b = &apos;林一一&apos;</span><br><span class="line">    console.log(&apos;b&apos; in window)</span><br><span class="line">    console.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">// 抛出 ReferenceError: a is not defined</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">console.log(v1);</span><br><span class="line">console.log(v2);</span><br><span class="line">console.log(v3);</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var v1 = v2 = v3 = 2019;</span><br><span class="line">    console.log(v1);</span><br><span class="line">    console.log(v2);</span><br><span class="line">    console.log(v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if 判断语句下的变量提升</span><br><span class="line">if(!(&quot;value&quot; in window))&#123;</span><br><span class="line">   var value = 2019; </span><br><span class="line">&#125;</span><br><span class="line">console.log(value);  // undefined if 条件语句中无论条件是否成立里面的var或者function 声明被提升</span><br><span class="line">console.log(&apos;value&apos; in window);  // true if 条件语句中无论条件是否成立里面的变量都会提升</span><br><span class="line"></span><br><span class="line">var a=2;</span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof a);</span><br><span class="line"></span><br><span class="line">// number 通过 var 声明之后，根据自上而下执行机制，函数声明被忽略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> var a = 10;</span><br><span class="line">   (function () &#123;</span><br><span class="line">       console.log(a)</span><br><span class="line">       a = 5</span><br><span class="line">       console.log(window.a)</span><br><span class="line">       var a = 20;</span><br><span class="line">       console.log(a)</span><br><span class="line">   &#125;)()</span><br><span class="line">   // undefined 10 20</span><br><span class="line">   // 存在两个作用域 全局作用域和匿名函数作用域， 函数作用域内因为有 var ，存在变量名提升，所以先打印 undefined， window.a 输出的是全局变量a，为10</span><br></pre></td></tr></table></figure></li></ol><h3 id="scope">作用域</h3><ol><li><p>考察作用域</p><p> 哪些语法会创建块级作用域：   </p><pre><code>1. try/catch,catch 分句会创建块及作用域，error 只能在内部调用2. with 3. let 会将变量绑定在任意作用域中，比如常见的 {} ,let 声明不会提升4.  {} 会创建块及作用域， 里面声明的变量或者函数无论条件是否满足，都会被变量提升</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">for(var i =0; i&lt; 5;i++) &#123; </span><br><span class="line">setTimeout((i) =&gt; &#123;console.log(i)&#125;, 0) </span><br><span class="line">&#125;</span><br><span class="line">// 5 5 5 5 5</span><br><span class="line"></span><br><span class="line">for(let i =0; i&lt; 5;i++) &#123; </span><br><span class="line">setTimeout((i) =&gt; &#123;console.log(i)&#125;, 0) </span><br><span class="line">&#125;</span><br><span class="line">// 0 1 2 3 4</span><br><span class="line"></span><br><span class="line">for(var i =0; i&lt; 5;i++) &#123; </span><br><span class="line">(function(i)&#123;</span><br><span class="line">setTimeout((i) =&gt; &#123;console.log(i)&#125;, 0)</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let i; // 此时的 i 仍声明在全局变量中</span><br><span class="line">for(i=0;i&lt;5;i++) &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;console.log(i) &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">// 5 5 5 5 5</span><br><span class="line"></span><br><span class="line">for(let i=0;i&lt;5;i++) &#123; // let 将 i 绑定到for 循环中，并且是将其重新绑定到每次循环中，所以可以得到 0 1 2 3 4</span><br><span class="line">setTimeout(() =&gt; &#123;console.log(i) &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function demo()&#123;</span><br><span class="line">    let x = b = 0;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br><span class="line">console.log(typeof x) x  //  undefined 只在函数内部声明，所以外部无法获取</span><br><span class="line">console.log(typeof b) b // number 并没有被声明，所以向上级作用域查找并最终添加到window.b ,var let const 在此场景下功效相同</span><br></pre></td></tr></table></figure></li></ol><h3 id="reg">正则表达式</h3><ol><li><p>正则表达式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;&lt;p&gt; Hello &lt;/p&gt; World &lt;br&gt;!&lt;/br&gt;&apos;;</span><br><span class="line">var regx = /&lt;[^&lt;&gt;]+&gt;/g</span><br><span class="line">console.log(str.replace(regx, &apos;&apos;));</span><br></pre></td></tr></table></figure></li></ol><h3 id="keys">object 的 key值的类型转换</h3><p>obj 的 key 如果是变量的话，会转换成 string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;</span><br><span class="line">var b = &#123;key:&apos;b&apos;&#125;</span><br><span class="line">var c = &#123;key:&apos;c&apos;&#125;</span><br><span class="line">var d = [3,5,6];</span><br><span class="line">var e = true</span><br><span class="line">var f = function test() &#123; console.log(1) &#125;</span><br><span class="line">var g = Symbol(1)</span><br><span class="line"></span><br><span class="line">a[b] = 123;</span><br><span class="line">a[c] = 345;</span><br><span class="line">a[d] = 333;</span><br><span class="line">a[e] = 111</span><br><span class="line">a[f] = 222</span><br><span class="line">a[g] = 444</span><br><span class="line"></span><br><span class="line">console.log(a[b]); // a[object Object]: 345</span><br><span class="line">console.log(a[c]); // a[object Object]: 345</span><br><span class="line">console.log(a[d]); // a[1,2,3]: 333</span><br><span class="line">console.log(a[e]); // a[&apos;true&apos;]: 111</span><br><span class="line">console.log(a[f]); // a[&apos;function test() &#123; console.log(1) &#125;&apos;]: 222</span><br><span class="line">console.log(a[g]); // a[&apos;Symbol(1)&apos;]: 222</span><br></pre></td></tr></table></figure><h3 id="methods"> js 方法</h3><ol><li><p>考察 array 数组方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4].reduce((x,y) =&gt; &#123;console.log(x,y); return x;&#125;)</span><br><span class="line"></span><br><span class="line"> // 输出结果</span><br><span class="line"></span><br><span class="line">A: 1 2; 3 3; 6 4;</span><br><span class="line">B: 1 2; 2 3; 3 4;</span><br><span class="line">C: 1 undefined; 2 undefined; 3 undefined; 4 undefined;</span><br><span class="line">D: 1 2; undefined 3; undefined 4;</span><br><span class="line"></span><br><span class="line">// reduce 不改变原数组，返回新数组</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>考察作用域，函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const value = &#123; number: 10 &#125;</span><br><span class="line">const mutlipt = (x = &#123; ...value &#125;) =&gt; &#123;</span><br><span class="line">console.log(x.number *= 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutlipt()</span><br><span class="line">mutlipt()</span><br><span class="line">mutlipt(value)</span><br><span class="line">mutlipt(value)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>考察加减</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let num = 10</span><br><span class="line">let increaseNum = () =&gt; num++;</span><br><span class="line">let increasePassedNum = (number) =&gt; number++;</span><br><span class="line"></span><br><span class="line">let num1 = increaseNum();</span><br><span class="line">let num2 = increasePassedNum(num1++);</span><br><span class="line"></span><br><span class="line">console.log(num1);</span><br><span class="line">console.log(num2);</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>JSON.stringify 第二个参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;test&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    email: &apos;qq.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">var b = JSON.stringify(a, [&apos;age&apos;, &apos;email&apos;])</span><br><span class="line"></span><br><span class="line">// 解读：</span><br><span class="line">JSON.stringify(value, replacer)</span><br><span class="line">replacer：</span><br><span class="line">如果是函数 则以该函数对所有value做格式化处理</span><br><span class="line">如果是数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；</span><br><span class="line">如果该参数为 null 或者未提供，则对象所有的属性都会被序列化</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>考察 Object.defineProperty, Object.keys</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; name: &apos;haha&apos; &#125;</span><br><span class="line">Object.defineProperty(person, &apos;age&apos;, &#123; value: 12 &#125;)</span><br><span class="line">console.log(person)</span><br><span class="line">console.log(Object.keys(person))</span><br><span class="line"></span><br><span class="line">// Object.keys 返回对象可枚举 enumerable 的属性</span><br><span class="line">// Object.defineProperty 定义的属性默认 enumerable configurable writable 为 false，get set value 为 undefined</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>考察 delete</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;111&apos;</span><br><span class="line">age = 18</span><br><span class="line">console.log(delete name)</span><br><span class="line">console.log(delete age)</span><br><span class="line"></span><br><span class="line">// 任何存在或者不存在的属性删除时 返回 true</span><br><span class="line">// 除非删除不可设置的属性时，返回 false ，使用 let / const 声明的变量</span><br><span class="line">// delete 只会删除自身属性 不会删除原型链上的属性</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>charAt </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;aaa we dasd&apos;</span><br><span class="line">console.log(str.charAt(3)) // &quot; &quot;</span><br><span class="line">console.log(str.chatAt(0)) // a</span><br><span class="line"></span><br><span class="line">小驼峰字符串：</span><br><span class="line"></span><br><span class="line">let capitalize = (value) =&gt; &#123;</span><br><span class="line">value = toString(value)</span><br><span class="line">let firstCode = value.charAt(0)</span><br><span class="line">let trailing = value.slice(1)</span><br><span class="line">return firstCode.toUpperCase() + trailing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>generator  生成器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* generator(i)&#123;</span><br><span class="line">  yield i</span><br><span class="line">  yield i * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gen = generator(10);</span><br><span class="line"></span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">// 10</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">// 20</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>set</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 一维数组去重 </span><br><span class="line">Array.from(new Set([1,1,2,2,3]))</span><br><span class="line"></span><br><span class="line">// 根据先进先出，获取最先插入的元素</span><br><span class="line">set.entries().next().value[0]</span><br><span class="line"></span><br><span class="line">// delete 操作返回值</span><br><span class="line">返回操作前 has 的值，存在当前值则返回 true， 不存在则返回 false</span><br><span class="line"></span><br><span class="line">// 值 大小写敏感并且不能重复</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.1 3. .3 都是合法的数字</span><br><span class="line">// 以下哪些情况会输出 ’3‘</span><br><span class="line">3.toString() // 解析为 (3.)toString()</span><br><span class="line">3..toString() // (3.).toString()</span><br><span class="line">3...toString() // (3..).toString()</span><br></pre></td></tr></table></figure></li><li><p>error 的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RangeError:  数值变量或参数超出其有效范围</span><br><span class="line">ReferenceError:  无效的引用，比如变量未定义</span><br><span class="line">SyntaxError: eval()在解析代码的过程中发生的语法错误。</span><br><span class="line">TypeError: 变量或参数不属于有效类型</span><br><span class="line">URIError: 给 encodeURI()或  decodeURl()传递的参数无效。</span><br></pre></td></tr></table></figure></li><li><p>手动书写 Promise.all </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function promiseAll (promises) &#123;</span><br><span class="line">let result = promised.map(promise =&gt; &#123;</span><br><span class="line">return promise.then(res =&gt; &#123;</span><br><span class="line">return Promise.reslove(res);</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">return Promise.reject(error);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
            <tag> 前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm install vs yarn install</title>
      <link href="/2020/12/04/npm-install-vs-yarn-install/"/>
      <url>/2020/12/04/npm-install-vs-yarn-install/</url>
      
        <content type="html"><![CDATA[<p>之前听说 yarn 挺快的，所以看了下文档就直接切换过来了，并没有很深入的对 npm install 和 yarn install 做深入了解和比较，今天终于有时间好好整理一下两者的关联</p><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>npm yarn 都是包管理工具，每个语言都有自己的包管理工具，Java 有 Maven, Python 有 pip，Ruby 有 gem, PHP 有 Composer, npm 就是 js 的包管理工具， npm 作为最早出来的唯一的 js 包管理工具，截止2016年7月，npm 的 registry上面已经注册了超过280,000个模块，所以 npm 很受欢迎，前端开发者也对他有很强的依赖，不过在使用过程中 npm 逐渐暴露出一些问题：</p><ol><li>安装时间较长，因为是同步请求，一个包安装完之后才会安装下一个包</li><li>安装版本不固定：同一份 package.json 安装可能出现不同的依赖树，导致出现 a 电脑上运行良好，b 电脑上运行出错的问题</li></ol><hr><h4 id="npm-的问题"><a href="#npm-的问题" class="headerlink" title="npm 的问题"></a>npm 的问题</h4><p>针对第二个问题，主要是在 npm v3 之前，还没有自动生成 package-lock.json 的时候，不同的安装行为就会生成不同的依赖树，那时的 npm 老是被吐槽安装慢，安装的不稳定性， 而 yarn 正是在 2016 年发布的，为了解决这些问题而诞生，但是并没有说 yarn 是可以完全替代 npm 的</p><p>这里说明下 npm 的安装原理：</p><ol><li>检查 node_modules 文件夹和 package-lock.json 文件是否存在，并跟踪现有的依赖关系（文件结构）克隆该数</li><li>读取 package.json 中需要安装的包，dev， devDepends 包括依赖项将其添加到克隆树上</li><li>将原始树和克隆树进行比较，安装新依赖，更新现有依赖版本，移动在树上的位置，移除不再需要的依赖，整个过程深度优先</li></ol><p><br></p><h4 id="安装流程图"><a href="#安装流程图" class="headerlink" title="安装流程图"></a>安装流程图</h4><p><img src="/images/npm-i.png" alt="npm 安装流程图"></p><h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><blockquote><p>Yarn — a fast, reliable, and secure alternative npm client.  — 出自官网</p></blockquote><h5 id="yarn-安装过程"><a href="#yarn-安装过程" class="headerlink" title="yarn 安装过程"></a>yarn 安装过程</h5><ol><li>解析：首先解析 package.json 文件，向包仓库发起请求 递归查询各层依赖</li><li>获取：先从全局缓存目录中查询是否有所需的包已经下载。没有的话 会先把这个包的 tarball 拉下来</li><li>链接：最后把所需的文件从缓存中复制到本地的 node_modules 目录中</li><li>生成 yarn.lock 文件</li></ol><hr><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p>与 npm 相比，yarn 具有如下优点：</p><ol><li>安装速度快<ol><li>并行下载: 有效地对请求进行排队处理，避免发起的请求如瀑布般倾泻，以便最大限度地利用网络资源。</li><li>支持离线模式：缓存下载的每个包，如果你以前安装过某个包，再次安装时可以在没有任何互联网连接的情况下进行。</li></ol></li><li>安全性高： 在下载前会校验每个包的完整性</li><li>可靠性高： 自动锁定包的版本和依赖关系，具体到指定版本，保证项目的每个成员下载的包的版本一致</li></ol><p>虽然目前的 npm v5 对于版本依赖有了好的优化，但是实际项目中安装时间，yarn 还是比 npm 快 20%-30% 左右， 所以我还是会选择 yarn 安装</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心安即是归处-成都</title>
      <link href="/2020/11/30/%E5%BF%83%E5%AE%89%E5%8D%B3%E6%98%AF%E5%BD%92%E5%A4%84-%E6%88%90%E9%83%BD/"/>
      <url>/2020/11/30/%E5%BF%83%E5%AE%89%E5%8D%B3%E6%98%AF%E5%BD%92%E5%A4%84-%E6%88%90%E9%83%BD/</url>
      
        <content type="html"><![CDATA[<p>当了三年的北漂，发现是真的没什么意思，下决定就是那么一瞬间，之后就是着手办理一些回成都的事宜。<br>5月份的一天，飞机降落成都，我回到了这个离开三年的城市。落地的一瞬间，我好开心。</p><p>成都的机场，湿热的空气，穿拖鞋的出租车师傅，提着行李箱的帅哥美女，一切都很亲切。上了一个女司机的车，一路带我飞，超车别车一套动作行云流水，嘴上还一直叹气，都是些傻逼司机。</p><p>转眼回来半年时间了，回来换了工作，有了男朋友，一切好像尘埃落定，我也开始思考5年后的自己会是怎样<br>以前在北京，觉得一切以后都离我好远，我没空也没理由去想特别未来的事情，回来之后就再也没有借口逃避了，该面对的都需要面对，这时你才会设身处地的去想我应该怎样活着，怎样才是我最和谐的状态。</p><p>谈恋爱，买房，买车，结婚，生小孩，上学，养老，理财这些问题无可避免，但是我喜欢成都的节奏和生活哲学。这些事可以一点一点的慢慢来，慢慢的在我热爱的土地上生根发芽。<br>真正的生活才刚刚开始，回来了就好好的接受这个事实，不再逃避，也不再畏惧，这可能就是心安吧，该怎么办就怎么办，有这么多亲人朋友在我身边呀～</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喜剧电影分享</title>
      <link href="/2020/03/18/%E5%96%9C%E5%89%A7%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/"/>
      <url>/2020/03/18/%E5%96%9C%E5%89%A7%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>这里主要是一些质量比较高的黑色幽默或者治愈系电影，我好这口，嘿嘿。</p><h4 id="《我不是王毛》"><a href="#《我不是王毛》" class="headerlink" title="《我不是王毛》"></a>《我不是王毛》</h4><p>这一部描写抗日的片子让我记忆深刻，先扬后抑，真实，让人反思。前段用喜剧色彩描写各种人物，后面比较悲剧。</p><h4 id="《一个勺子》"><a href="#《一个勺子》" class="headerlink" title="《一个勺子》"></a>《一个勺子》</h4><p>觉得别人是个勺子，最后发现自己还不如个勺子，自己其实也是个勺子，陈建斌和蒋勤勤主演，陈建斌导演的，发现这个人还是比较有想法的，这并不是一部具有流行色彩的电影，看的人需要有耐心</p><h4 id="《半个喜剧》"><a href="#《半个喜剧》" class="headerlink" title="《半个喜剧》"></a>《半个喜剧》</h4><p>渣男是真的渣，男主是真的怂。任素汐演的是真好，戏剧性的冲突太多了，各种巧合也只有拍电影能解释了，不过吧，我还挺记忆深刻的，现实中还真有不少这种例子的男生。</p><h4 id="《冠军》马东锡"><a href="#《冠军》马东锡" class="headerlink" title="《冠军》马东锡"></a>《冠军》马东锡</h4><p>暖心喜（爽）剧，韩国的演员就是一点儿都不做作，冲着马东锡去得，反差萌太可爱了。</p><h4 id="《孝子洞理发师》宋康昊"><a href="#《孝子洞理发师》宋康昊" class="headerlink" title="《孝子洞理发师》宋康昊"></a>《孝子洞理发师》宋康昊</h4><p>开在青瓦台附近的理发店，从一个理发师的角度看到了韩国总统更替等诸多历史事件，并描述了他平凡的一生，治愈剧，主演是 宋康昊，杀人回忆的主演</p>]]></content>
      
      
      <categories>
          
          <category> movie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 喜剧电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首-2019</title>
      <link href="/2020/01/05/%E5%9B%9E%E9%A6%96-2019/"/>
      <url>/2020/01/05/%E5%9B%9E%E9%A6%96-2019/</url>
      
        <content type="html"><![CDATA[<p>开始前，看了下之前3年的总结，现在自己点评下：直白，稚嫩，语言苍白无力，哈哈哈 原来自己看自己写的东西是这种感觉。不过，记录下来终归是好的，可以了解下每一年的自己，发现一年比一年更熟悉自己，更能接受自己。</p><p>2019年，我又学会了很多，又是健康成长的一年，嘿嘿。</p><hr><h5 id="生活："><a href="#生活：" class="headerlink" title="生活："></a>生活：</h5><p>自己的人生观和价值观发生了比较大的变化。遇到了不同的人，他们的言行对我产生了影响，看了几本书，书中的道理让我觉得自己的思想还是比较狭隘和简单，也更深的认识到需要控制自己的情绪，调整自己的想法才能成为那个自己喜欢的自己。</p><p>A朋友，做事情目的性很强，并且还不断的自我提升，把解决问题当成乐趣，并且还懂得调整姿势和坚持去达到目的，刚开始这是让我很惊讶的。因为一般人都会在做事情的途中迷失，忘记了最初的目的，反而去被周围环境所影响，最后甚至是不了了之。这一点值得我学习。任何事都至少有三种解法，如果你失败了只能说明方法不对，并不是你能力有问题，不要被消极的情绪左右你的行为。</p><p>B朋友，知心大姐，或者叫暖心大姐。给了我很多正面的鼓励，并且也严厉纠正我了一些不正确的习惯和消极的想法，现在她已经能独当一面，并且收到众多好评。从她那里我体会到：授人以鱼不如授人以渔，多给身边人带去积极情绪而不是散发消极情绪，人们都是向着太阳生长的，负面情绪太多害人害己。我之前是一个爱憎分明的人，如果别人有做的不对的地方，我会直接说出来，在说话上用点技巧或者说情商高点，大家都能接受并且乐于改正。这些其实都不是她直接告诉我的，但是她所做的一切我都在看在眼里。之前觉得这种知心或者暖心只是因为这个人性格比较好，其实吧，她性格也不是很好，哈哈哈，能做到这样确实让人佩服。</p><p>有一次，被人亲口质问：你想过10年之后的你是什么样吗？真的，对我震撼很大，我陷入了自我怀疑，很焦虑，也很颓废， 那段时间突然想去找一些哲学或者心理学方面的书看看，重塑心灵，这本书给了我很大的启发，详见 【重塑心灵-读后感】。我慢慢的接受了自己，并且在平常的生活和工作中去控制自己的情绪，尝试有效沟通，经常审视自己，不断的想要了解潜意识的我是怎么想的，然后去认识真实的自己。我可以自己问自己你知道你在干什么吗？ 但是我受不了别人来问我，感觉像它走到了我最私密的地方，看到了不该看到的东西，而我完全暴露在它面前了。</p><hr><h5 id="工作："><a href="#工作：" class="headerlink" title="工作："></a>工作：</h5><p>去年能力比较强的小哥哥和小姐姐都陆续离开了我们组，我被留下来了。心里的落差难免会有，但是后来我想明白了，之前其实是有人走在前面，现在他们走了，就是我站在最前面，接触到最核心的基层架构和最全面的业务。所以考验我的时候来了。</p><p>今年咱们业务线把之前诟病的地方优化了60%，也带了两波同学进组。才深知带人的复杂度和接口人的难处，有段时间由于业务较多，人员不足并且时间紧迫，压力比较大，甚至是不想上班，但是我知道越是扛不住的时候越说明痛苦的时候快过去了，所以告诉自己再坚持坚持，这波完了给自己好好休个假补回来。事实上也是这样的，哈哈，去了趟泰国的普吉岛，充满电，再投入到工作中，觉得我爱这样的生活，有张有驰，不喜欢一成不变的日子。</p><p>年底评了个优秀个人，说实话自己开心的很，觉得自己的工作能力被认同了，同时也知道下一年会有更大的挑战等着我。人就是这样一步一步前进，如果有一天你停下来了，也会有东西逼着你被迫前进的。</p><hr><h5 id="明年："><a href="#明年：" class="headerlink" title="明年："></a>明年：</h5><p>希望自己变得更沉稳，温柔。<br>坚持一件事 一年<br>愿得一人心</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clean code</title>
      <link href="/2019/09/05/clean%20code/"/>
      <url>/2019/09/05/clean%20code/</url>
      
        <content type="html"><![CDATA[<p>工作以来深有体会代码规范的重要性，直接影响你的工作心情。看到不好的代码，想好言相劝，并且有理有据，并且从根本上杜绝这种对自己代码不负责的行为，所以啃了本 代码整洁之道，从中得到了不少启发，并且为规范找到的好的依据点，在这里做一个总结，留个案底～</p><p><a href="#variable">命名约定</a><br><a href="#function">函数</a><br><a href="#class">类</a><br><a href="#object">数据结构</a><br><a href="#comment">注释</a><br><a href="#error-handle">错误处理</a><br><a href="#unit-test">单元测试</a><br><a href="#unit-test">一般性问题</a><br><a href="#unit-test">几个原则</a></p><h4 id="variable">命名约定</h4><p>使用有意义 可读性好的描述性变量名，别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p><h4 id="function">函数</h4><ol><li><p>短小 </p><p> 推荐编写简短精悍的函数，承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p></li><li><p>只做一件事， 单一责任原则， 并且一个函数就一个抽象层级</p></li><li>自上而下写函数，最小惊异原则</li><li><p>合理的使用 if/else 和 switch 语句</p><p> switch 语句由于独特的case值判断逻辑，执行效率上优于 if/else<br> switch 通常用于多态， case 参数为一种类型的多个值， if/else 则用于满足明确不同条件范围的语境<br> 根据不同语境，适当采用不同方法</p></li><li><p>函数参数</p><p> 最好是零参数<br> 其次是一元，二元，三元，参数越多，出现的问题可能越到，测试用例也会越多<br> 正确使用标识参数，比如为函数传递 boolean，就明确标识了函数不止做一件事，这时应该重新考虑的函数<br> 通常情况下，参数超过两个意味着函数功能过于复杂，参数过多的时候，尤其是超过三元，请注意你的参数是否在描述同一个事物，如果是，可以使用参数对象<br> 输出参数</p></li><li><p>无副作用</p><p> 你的函数名应该能足够反映你的函数能力，不能存在隐含逻辑</p></li><li><p>移除重复的代码</p><p> 永远不要在任何循环下存在重复代码</p></li><li><p>采用默认参数精简代码</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">反例： </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject, body</span>) </span>&#123;</span><br><span class="line">    subject = subject || <span class="string">'No Subject'</span>;</span><br><span class="line">    body = body || <span class="string">'No text'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeForumComment</span>(<span class="params">subject = <span class="string">'No subject'</span>, body = <span class="string">'No text'</span></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封装判断条件</p><p> 当你的判断条件具有特殊意义，并且判断条件超过两个时，考虑抽象成一个良好命名的函数，便于理解</p></li><li><p>删除无效代码</p><p>不再被调用的代码应该被立即删除</p></li></ol><h4 id="class">类</h4><ol><li>类应该短小，单一职责， 每一个小类的封装应当只有一个权责和一个修改的原因</li><li><p>多造几个工具而不是多造几个抽屉</p><p> 有许多短小类的系统并不比有少量庞大类的系统拥有更多移动组件，其数量是大致相等的，问题在于你是想多造几个工具归类到标记和定义良好的组件的工具箱还是想要几个能把所有东西都扔进去的抽屉</p></li><li><p>软件能工作和软件保持整洁，是完全不同的高度， 软件能工作并不意味着万事大吉，后者更重要</p></li><li><p>隔离修改</p><p> OPI：依赖倒置原则，类应该依赖于抽象类，而不是具体实现类</p></li></ol><h4 id="object">数据结构</h4><p>对象： 暴露行为，隐藏结构<br>数据结构： 暴露结构，没有明显的行为<br>这章不是很懂。</p><h4 id="comment">注释</h4><p>原则： 尽量别写注释</p><ol><li><p>注释会存在的问题：</p><ul><li>不恰当的信息： 注释只应该描述有关代码设计的技术型信息</li><li>废弃的注释：过时 无关和不正确的信息 以及废弃的代码应该及时更新和删除</li><li>冗余注释： 注释应该谈及代码自身没提到的事情</li><li>糟糕的注释： 应该是正确的拼写和语法 保持整洁</li><li>注释掉的代码： 注释掉的代码应立即删除 源代码控制系统会帮你记住</li></ul></li><li><p>可以注释的：</p><ul><li>提供有用的信息，比如 法律信息，参考文档链接等</li><li>对某个决定的说明</li><li>阐释性注释</li><li>警示</li><li>todo</li></ul></li><li><p>不需要注释的：</p><ul><li>和代码上下文无关，个人主观描述等</li><li>旧注释： 无人维护和上下文不符</li><li>日志式注释</li><li>author </li><li>注释掉的代码</li><li>函数头注释， 取一个好理解的函数名可替代注释</li></ul></li></ol><h4 id="error-handle">错误处理</h4><ol><li>错误处理的建议方法： 抛出异常而不是返回错误码，便于隔离错误处理，其逻辑不被错误处理所影响</li><li>try catch finally ，学会用这样的方式处理你的代码逻辑，保证代码的正常运行。try </li><li>提供充足的错误环境说明，定位问题</li><li>依调用者的需要定义异常类</li><li>不要返回 null 或者传递 null 值，去增加业务逻辑</li></ol><p>总结： 代码可读和强固并不冲突，将错误处理隔离开来，独立于业务逻辑，就会变的可读并整洁</p><h4 id="unit-test">单元测试</h4><p>TDD 三定律：</p><p>定律一： 在编写不能通过的单元测试前，不可编写生产代码<br>定律二： 只可编写刚好无法通过的单元测试，不能编译不算通过<br>定律三： 只可编写刚好足以通过当前失败测试的生产代码</p><p>测试的好处： 有了测试你就不担心修改代码了，你的代码就变得 可扩展，可维护，可复用，并且代码测试覆盖率高</p><p>每一个测试一个概念，不在一个冗长的测试函数中包含多个职责或概念</p><p>FIRST 规则：</p><ol><li>F fast 快速： 测试运营应该足够快</li><li>I Independent 独立： 测试之间应该相互独立</li><li>R Repeatable 可重复： 测试应当可在任何环境中重复通过</li><li>S Self-valiating 自足验证； 测试应该有布尔值输出</li><li>T Timely 及时： 测试应该及时编写</li></ol>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码整洁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常工具</title>
      <link href="/2019/07/23/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/07/23/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>前端工作中日常会遇到的一些工具，对于比较有意思的做一个记录</p><ol><li>数组去重</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对于一维纯数组：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(numbers)]);</span><br><span class="line"></span><br><span class="line">对于数组对象：</span><br><span class="line"><span class="keyword">const</span> arrayObjs = [&#123; <span class="attr">a</span>: <span class="string">'haha'</span>&#125; ,&#123;<span class="attr">b</span>: <span class="string">'hihi'</span>&#125;, &#123;<span class="attr">c</span>: <span class="string">'xixi'</span>&#125;, &#123;<span class="attr">d</span>: <span class="string">'hihi'</span>&#125;, &#123;<span class="attr">e</span>: <span class="string">'haha'</span> &#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重塑心灵-读后感</title>
      <link href="/2019/07/08/%E9%87%8D%E5%A1%91%E5%BF%83%E7%81%B5-%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/07/08/%E9%87%8D%E5%A1%91%E5%BF%83%E7%81%B5-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>今年已然过去了一半，25的我被繁杂的工作牢牢禁锢的时候，让我引起深思，原来从一开始我就是那个一头扎进工作的加班狗，从毕业到现在已经当了3年的狗了。</p><p>三年过去，我绝望的望着自己辛苦耕耘的这片贫瘠的土地，我得到了什么？我为了什么？我在干什么？</p><p>中国人最常挂在嘴边的教导人的话就是付出就会有收获，踏实肯干，你就会成功。原本以为，自己工作多花时间了，就会比别人强一点，自己看书了，自己多加班了就会比别人做的多一些，收获也就多一些。最终发现，事情并不是这样，你的努力如果没有目标，你看的书如果没有看懂，你加的班如果只是在写无谓的面条代码，那么你只是在浪费时间，浪费精力，自欺欺人罢了。</p><p>有人推荐了我一本书 - 重塑心灵，在那段极度烦闷和讨厌自己的日子里，它给了我思路。</p><ol><li><p>自责和力不从心那是你的潜意识和意识不一致，你还没有完全了解你自己总给自己设置一些无法完成的目标和期望来禁锢自己，是自己有挫败感，无力感。</p></li><li><p>同一件事情在不同人眼里就会有不同的看法，不要去想当然的认为所有人都跟你想的一样，延伸为每两个人都是不同的，你无法改变别人也不应该改变任何人</p></li><li><p>有情绪是很正常的一件事情，要接受自己的所有情绪，相反如果你为了麻痹自己，抗拒情绪的产生，长时间之后，你的所有情绪都会变得麻木，对任何事没有情绪，你就会觉得生活枯燥乏味，想自己活着是为了什么，这个时候就要学会表达和管理自己的情绪，放大正面情绪，从负面情绪中汲取正面价值并且淡化负面情绪，你的生活就会变得有活力有色彩，每天的你都干劲十足。</p></li><li><p>跟人有效沟通的必要前提就是你得真诚，先把气氛缓和下来再进入沟通，被沟通者更容易接受，不产生抗拒，人们在比较放松的环境下才会很自然的表露自己的真实想法。有没有效果取决于被沟通者的反馈，而不是你的表达。</p></li><li><p>什么是压力？当你认为处理事情所需要的能力超出你拥有的能力时，你便感到压力。压力不完全由负面情绪产生，学会给自己减压，多睡觉，唱歌，或者把对自己的标准适当降低，或者自我暗示都能缓解压力。</p></li><li><p>乐观的人生态度很重要，凡事都至少有3种解决方法，思维灵活，如果一种做法不能成功那只能说明你的做法有问题，并不代表你的能力有问题。一种不行就换下一种，灵活处事。</p></li><li><p>不要限制自己，跨越我肯定不行和我不会成功的自我限制，不自傲也不自卑，相信自己可以做到</p></li><li><p>直面真实的自己，接受自己才能更好的使用自己</p></li><li><p>愤怒是人们对自己的保护，自我价值不足的人常喜欢通过贬低他人的方式来平衡自己，这是一种不好的心理。原谅那些经常抱怨和怼你的人。</p></li><li><p>常常思考 如何能做得更好？如何提升自己，保持对事物的好奇和兴趣，练习有效率的做事情并且只给自己一次机会把事情做好。</p></li></ol><p>终于，在每天的迷茫和自责中，我找到了是自己心安和稳步前进的方法。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> 人生 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首-2018</title>
      <link href="/2018/12/07/%E5%9B%9E%E9%A6%96-2018/"/>
      <url>/2018/12/07/%E5%9B%9E%E9%A6%96-2018/</url>
      
        <content type="html"><![CDATA[<p>今年的总结来了<br>发现每年的我都不一样，说明自己在成长，开心开心～</p><p>今年入职了一家新公司，工作上成长了不少，需要感谢很多人，尤其是旁边的大姐姐，很负责，很细心，很耐心，让我纠正了很多以前的坏习惯。身边的同事也都很可爱（当然，我最可爱）；</p><p>对工作有了新的认识，回头看以前的自己，格局太小，心思太少，压力太少，内存也太少。<br>对工作的态度影响了很多东西，你的每一个行为都有蝴蝶效应。</p><p>发现时间不够用<br>发现事在人为<br>发现坚持很重要</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 2018 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用操作</title>
      <link href="/2018/11/16/git%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/16/git%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="收集一些关于git的日常操作"><a href="#收集一些关于git的日常操作" class="headerlink" title="收集一些关于git的日常操作"></a>收集一些关于git的日常操作</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone url</code> 根据url将代码克隆到本地<br><code>git clone url reponame</code> 当自定义前目录名</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 检查当前文件状态，记录从上次提交后所有文件状态<br><code>git status -s</code> 显示简洁版的文件状态<br><code>git status -b</code> 根据分支显示状态信息<br><code>git status --ignored</code> 显示被忽略文件的状态信息  </p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add  filename</code> 开始跟踪新文件<br><code>git add -A/*</code>  跟踪所有未跟踪文件，将其放到本地仓库的暂存区</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p><code>touch .gitignore</code> 创建需要忽略的文件规则,摘自<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">Git</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit -m commitInfo</code> 提交到仓库，commitInfo 为提交信息<br><code>git commit -a -m commitInfo</code> 跳过 <code>git add</code> 操作，自动暂存跟踪过文件的修改，并添加提交信息，<strong>注意未跟踪过的文件不能跳过 git add 操作</strong><br><code>git commit --amend</code> 修改最后一次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;initial commit&apos; // 修改最后一次提交</span><br><span class="line">git add forgotten_file    // 添加忘记跟踪文件</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset HEAD filename</code> git commit之后，取消已暂存的文件<br><code>git reset --hard commitNum</code> 回到某个版本号<br><code>git reset --hard HEAD^</code> 回退到上一个版本号</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>当你提交或修改分支时,记录每次命令操作,可用于从新版回退到旧版又需要回退到新版时获取最新版commitnum</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><code>git checkout --[filename]</code> git add 之后，取消对文件的修改<br><code>git checkout [branch_name]</code> 切换到某分支<br><code>git checkout -b [branch_name]</code> 如果没有则新建此分支并切换到</p><p><strong>说明: 任何已经提交过的文件对于 git 来说都是可以恢复的，即便已经删除，除了从没有提交过的文件，对于 git 来说就像从没有存在过</strong></p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p><code>git diff</code> 检查已跟踪文件尚未暂存的文件有哪些改动<br><code>git diff --cached</code> 已经写入缓存的改动</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p><code>git rm file_path</code> 删除暂存区中的文件，工作区上的也会被删除<br><code>git rm --cached file_path</code> 删除暂存区中的文件，工作区上还会保留<br><code>git rm -r -n --cached file_path</code> 加上<code>-n</code>,列出将会删除的远程文件列表<br><code>git rm -r --cached file_path</code> 删除远程仓库文件列表，记得提交commit，然后push到仓库，才会生效</p><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p><code>git config [--local|--global|--systerm] -l</code> 查看仓库级别｜全局级别｜系统级别的配置信息<br><code>git conifg --global user.name username</code>, <code>git config --global user.email email</code>  初次运行时配置，该信息将存在用户主目录下，以后所有的项目提交默认使用此配置信息，如果想针对某个仓库使用其他名字和邮箱，只需要去掉<code>--global</code>参数即可</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git branch</code> 查看当前本地仓库所有分支，并且能看出当前处于哪个分支上<br><code>git branch -a</code> 查看仓库所有分支，包括远程分支<br><code>git branch -v</code> 查看本地仓库各个分支最后一个提交对象的信息<br><code>git branch -a -v</code> 查看仓库所有分支最后一个提交对象的信息<br><code>git branch --merged</code> 查看哪些分支已被并入当前分支<br><code>git branch --no-merged</code> 查看尚未合并的分支<br><code>git branch -d [branch name]</code> 删除已经被合并的某个分支，前提是前面没有 <em> 号<br><code>git branch -D [branch name]</code> 删除未被合并的某个分支<br>`git branch | grep ‘bugfix/</em>‘ | xrags git branch -d`  批量删除本地分支 以 bugfix/开头的分支</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p><code>git remote</code> 列出远程仓库的简短名字<br><code>git remote -v</code> 列出远程仓库对应的克隆地址<br><code>git remote add [shortname] [url]</code> 添加一个远程仓库并起名</p><h3 id="git-prune"><a href="#git-prune" class="headerlink" title="git prune"></a>git prune</h3><p><code>git remote prune -n</code>  预览即将被清除的无效的远程分支<br><code>git remote prune</code>  清除无效的远程分支</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><code>git fetch [远程主机名]</code> 拉取远程主机所有分支更新到本地<br><code>git fetch [远程主机名]:[分支名]</code> 拉取远程主机指定某个分支代码到本地，但是不做合并操作<br><code>git fetch --prune</code>  拉取远程有效分支</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><code>git merge --abort</code> 合并导致冲突时，放弃合并并试图回到合并前状态<br><code>git merge</code> 合并提交，当两个分支都有修改时，只创建一个新的提交，之前的合并记录在合并之后会丢失</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><code>git rebase</code> 当合并两个都有修改的分支时，被合并分支会直接添加到合并分支上，并且此时的 HEAD 并不会随着合并而移到最新提交前，需要再执行 merge 操作使其 HEAD 前移</p><p>参考<a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html" target="_blank" rel="noopener">git merge 与 git rebase 的区别</a></p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global push.default matching / simple</span><br></pre></td></tr></table></figure><p><code>git push</code> 将本地分支的更新提交到远程仓库,默认会推送到与本地分支建立追踪关系的分支，如果没有则新建<br><code>git push [远程主机名] ［本地分支名]:[远程分支名]</code> 将本地分支的更新提交到远程仓库的指定分支<br><code>git push --force origin</code> 强制将本地分支推送到远程上<br><code>git push --all origin</code> 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机  </p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code> 当前分支只有一个追踪分支，并已经建立关系，可以省略主机名和分支名<br><code>git pull origin</code> 当前分支与远程已经建立关系，可以省略分支名<br><code>git pull --rebase</code> 采用 rebase 模式合并，默认是 merge 模式<br><code>git pull -p</code> 在拉取过程中如果远程分支已删除，加上 <code>-p</code> 参数会同时删掉本地分支，默认情况下是不会删除的<br><code>git pull [远程主机名] ［远程分支名]:[本地分支名]</code>  拉取远程主机某个分支的更新，再与本地的指定分支合并，当远程分支和当前分支合并时，本地分支名可以省略</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code> 将当前未提交的修改保存到 Git 工作栈中<br><code>git stash pop</code> 将保存的东西取出来</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry pick"></a>git cherry pick</h3><p><code>git cherry-pick commitid</code> 将另一分支的指定 commitid 合并到当前分支，使用场景： 稳定分支上想合并添加的新功能commitid<br><code>git cherry-pick startcommitid...endcommitid</code>  表示将从 start 开始到 end 的commit 合并到当前分支， 区间为左开右闭，如果想包含startcommitid 执行<br><code>git cherry-pick startcommitid^...endcommitid</code></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol><li><p>区分本地版本库和远程版本库的状态</p><p><code>git status</code> 查看未提交到远程的提交记录<br><code>git cherry -v</code> 查看到未传送到远程代码库的提交描述/说明<br><code>git log [本地分支] ^[远程主机名/远程分支名]</code> 查看指定追踪线路的未传送提交的详细信息<br><code>git log -p</code>  查看更详细的提交记录</p></li></ol><ol start="2"><li>撤销操作，代码回滚</li></ol><ul><li><p>只存在工作区，未提交到暂存区 <code>git checkout --[pathname]</code>    </p><ul><li><code>git checkout .</code> 当前目录所有修改的文件恢复成未修改的样子</li><li><code>git checkout commit_id file_name</code>  取出文件 file_name 在 commit_id 的版本 <ul><li><code>git rm -r --cached file_name</code>  删除已存到暂存区文件，但是还未 commit 的文件</li></ul></li></ul></li><li><p>存在暂存区，也就是已经被提交</p><ul><li><code>git revert commit_id</code> 回滚指定commit_id 的代码，会产生一个新的 commit_id，就是将这次的修改给改回去， 会保留之前的修改记录也就是 commit_id，使用场景是：回滚到指定状态的样子，但是修改的提交还需要保留</li><li><code>git reset commit_id</code> 回退到指定 commit_id ，不会产生新的 commit_id, 之前的提交会被删除，完全回到文件修改前的状态 </li></ul></li></ul><ol start="3"><li><p>新开分支并拉取远程指定分支</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch  //可以将远程分支信息获取到本地</span><br><span class="line">git checkout -b localbranch_name origin/remote-branch</span><br></pre></td></tr></table></figure></li><li><p>npm 切换源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 永久切换</span><br><span class="line">npm config set registry url</span><br><span class="line"></span><br><span class="line">// 临时切换</span><br><span class="line">npm install  pkg --registry=url</span><br></pre></td></tr></table></figure></li><li><p>使用nrm管理npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br><span class="line">nrm ls // 列出所有仓库地址</span><br><span class="line">nrm use cnpm   // switch registry to cnpm</span><br><span class="line">nrm add 360es http://registry.npm.360es.cn  // add registry</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文艺电影分享</title>
      <link href="/2018/06/04/%E6%96%87%E8%89%BA%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/"/>
      <url>/2018/06/04/%E6%96%87%E8%89%BA%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="《春光乍泄》"><a href="#《春光乍泄》" class="headerlink" title="《春光乍泄》"></a>《春光乍泄》</h4><p>黎耀辉 何宝荣，当你爱上一个人的时候，就给了他伤害你的机会；伤痕累累的时候，你就知道痛了，默默离开，相忘于江湖，但是伤疤无法抹去了</p><h4 id="《花样年华》"><a href="#《花样年华》" class="headerlink" title="《花样年华》"></a>《花样年华》</h4><p>看完还是不明白为什么不能在一起  </p><h4 id="《一夜到永远》"><a href="#《一夜到永远》" class="headerlink" title="《一夜到永远》"></a>《一夜到永远》</h4><p>爱情观  </p><h4 id="《离开拉斯维加斯》"><a href="#《离开拉斯维加斯》" class="headerlink" title="《离开拉斯维加斯》"></a>《离开拉斯维加斯》</h4><p>悲观，无法拯救，自我放弃，“你永远不能让我戒酒”   </p><h4 id="《call-me-by-your-name》"><a href="#《call-me-by-your-name》" class="headerlink" title="《call me by your name》"></a>《call me by your name》</h4><p>正视真实的自己，人生有很多不如意，请记住那些美好  </p><h4 id="《小森林》"><a href="#《小森林》" class="headerlink" title="《小森林》"></a>《小森林》</h4><p>如果有一段时光可以这样度过，很舒服  </p><h4 id="《傲慢与偏见》"><a href="#《傲慢与偏见》" class="headerlink" title="《傲慢与偏见》"></a>《傲慢与偏见》</h4><p>觉得男主不成熟，但是好歹愿意正视自己的感情  </p><h4 id="《废纸板拳击手》"><a href="#《废纸板拳击手》" class="headerlink" title="《废纸板拳击手》"></a>《废纸板拳击手》</h4><p>曾经想成为一个流浪汉，什么都没有，过一天算一天的那种，后来发现即使是流浪汉也有自己在乎的东西  </p><h4 id="《绝美之城》"><a href="#《绝美之城》" class="headerlink" title="《绝美之城》"></a>《绝美之城》</h4><p>我们都过着残破的生活，你不应该高高在上，狗眼看人低，我们都在绝望的边缘，能做的就是照看彼此，陪伴彼此 开开玩笑   </p>]]></content>
      
      
      <categories>
          
          <category> movie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文艺电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端布局方法比较</title>
      <link href="/2017/12/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
      <url>/2017/12/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="缩放布局"><a href="#缩放布局" class="headerlink" title="缩放布局"></a>缩放布局</h2><p>根据 zoom 和 transform 的 scale 两种方式进行缩放。在这两者之间，zoom 缩放之后容器所占据的空间会跟着一起缩放，而scale 之后，容器所占据的空间不会变；并且 zoom 缩放之后渲染的清晰度比 scale 好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">realWidth, id</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> elm = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setZoom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> cliWidth = <span class="built_in">document</span>.doucmentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">elm.style.zoom =  cliWidth / realWidth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setZoom, <span class="literal">false</span>);</span><br><span class="line">setZoom();</span><br><span class="line">&#125;)(<span class="number">640</span>,<span class="string">'box'</span>); <span class="comment">// 根据640设计稿适配</span></span><br></pre></td></tr></table></figure><p>此种方法优点是能根据设备窗口自动缩放页面，缺点是高度和宽度都会被等比缩放，所以不适合有滑屏操作的页面</p><h2 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h2><p>百分比布局算比较简单的适配布局，并且能够很好的解决设备尺寸碎片化严重的情况，兼容性也很好。在百分比布局中熟练使用 margin 和 padding 能让工作事半功倍。</p><p>要灵活使用百分比布局，首先有个很关键的问题需要我们弄明白：百分比都是以什么为基础的百分比。有人说是父元素，但是这个回答太笼统了，接下来详细说明一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">width/height : 父元素</span><br><span class="line">margin/padding :  任意方向的百分比都参照的是父元素的宽度，因为css规范默认是横向排版，通常宽度较为固定，如果想参照高度，可以通过对父元素 -webkit-writing-mode:vertical-lr; 改变排版方向。</span><br><span class="line">font-size : 父元素的font-size,可以继承得到。</span><br><span class="line">line-height : 元素自身的font-size</span><br><span class="line">vertical-align : 参照元素自身的line-height.</span><br><span class="line">top/bottom : 参照父元素的高度</span><br><span class="line">left/right : 参照父元素的宽度</span><br><span class="line">border-radius : 参照自身元素尺寸。eg:元素width:<span class="number">200</span>px,<span class="attr">height</span>:<span class="number">100</span>px; border-radius:<span class="number">40</span>% = <span class="number">80</span>px/<span class="number">40</span>px;</span><br><span class="line">background-position : 初始值为<span class="number">0</span>% <span class="number">0</span>%；参照背景图片定位区域的大小减去背景图片的大小</span><br><span class="line">transform: translate : 参照自身元素的高宽</span><br></pre></td></tr></table></figure><p>请注意：当百分比值用于可继承属性时，<strong>只有结合参照值计算后的绝对值会被继承，而不是百分比值本身。</strong> 例如，一个元素的font-size 是 14px，并定义了 line-height:150%;，那么该元素的下一级子元素继承到的 line-height 就是21px，而不会再和子元素自己的 font-size 有关。</p><p>此方法适合页面内容结构均匀分配,固定高度,结构不是很复杂。并且注意此时的meta标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h2><p>rem 是 css3 中的一种尺寸单位。具体计算方法是根据 <strong><html></html></strong> 节点的 font－size 值决定的。比如此节点的 font－size 是 14px；那么 1rem 就表示 14px；</p><p>正是利用此原理，来达到通过修改跟节点的 font－size 值而一发而动全身的修改了页面 dom 尺寸来适配各种尺寸的页面。</p><p>与 em 类似，都是浏览器最后将他们转换为固定的 px 值，但是他们的区别就在于是根据谁来转化为 px。rem 只认 <strong>html</strong> 节点，而 em 是相对于父元素的 font－size 而决定的，也正是因此很容易被继承的 font－size 所影响。</p><p>通常在适配页面中，会以一个固定尺寸比如 640 像素的页面书写，然后通过修改 html 节点的 font-size 值来修改 1rem 所代表的实际 px 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.addEventListener) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.doucmentElement;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFont</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">html.style.fontSize = <span class="number">100</span> * (windth/<span class="number">640</span>) + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此方法适用范围比较广泛，在移动端浏览器上使用优先。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> 百分比布局 </tag>
            
            <tag> 缩放布局 </tag>
            
            <tag> rem布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首-2017</title>
      <link href="/2017/12/05/%E5%9B%9E%E9%A6%96-2017/"/>
      <url>/2017/12/05/%E5%9B%9E%E9%A6%96-2017/</url>
      
        <content type="html"><![CDATA[<p>从春暖花开的3月到零下3度的12月 test<br><br>从没见过暖气的南方银到见过暖气的南方银<br><br>从不怎么爱爬山的单身狗到喜欢爬山看世界的单身贵族<br><br>从不喜欢一个人吃饭逛街看电影唱歌到一个人把这些通通做了觉得也不过如此<br><br>从每天浪到两三点才入睡到现在看到12点就自觉放下手机躺到床上闭上眼睛<br></p><p>从依赖别人到相信自己<br><br>从喜欢抬头看周围的一切到只喜欢低头快步回家再到喜欢抬头看周围并慢下脚步，面带笑容<br><br>从毛毛燥燥到意识到什么叫有条不紊，有耐心<br><br>从畏惧新事物到万丈高楼平地起<br><br>从这座城与我无关到想留下点痕迹<br><br>等等…</p><p>我变了</p><p>留给自己的时间多了，你会更了解自己。<br>再也不随便给人贴标签了，每个人都是独特有性格的，只是你不了解而已。</p><p>能容纳别人和我有截然不同甚至让我鄙视厌恶的想法，因为每个人经历的不一样。能接受一个人同时存在值得赞美的优点和让人十分厌恶的缺点，因为每个人的柔软和盔甲不一样。</p><p>无论什么人都不会讨厌发自内心的微笑，也并不是为了迎合他人，但是得学会微笑。人生的苦闷比快乐多得多，能笑的时候就多笑笑。遇到问题别急着指责他人或者埋怨自己，先把问题解决咯，再从中汲取教训，顺便调侃一句怎么当时傻逼了呢。你一句话不说，别人只会想这个人肯定在心里骂我傻逼。。。顺便说一句，别只会甩锅，你牛逼把问题先解决了，再来讲明白来龙去脉，是谁的锅，谁心里清楚。</p><p>日子慢慢过，bug一个一个的改。</p><p>完。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北京  2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信H5支付之回跳 safari 浏览器</title>
      <link href="/2017/12/04/%E5%BE%AE%E4%BF%A1H5%E6%94%AF%E4%BB%98%E4%B9%8B%E5%9B%9E%E8%B7%B3%20safari%20%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2017/12/04/%E5%BE%AE%E4%BF%A1H5%E6%94%AF%E4%BB%98%E4%B9%8B%E5%9B%9E%E8%B7%B3%20safari%20%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>最近，公司发布一款新产品，需要在 iOS App 上集成微信 H5 支付（嗯，我知道微信官方建议我们不要在APP环境下使用H5支付）。用到的关键步骤如下，参考文档<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_1" target="_blank" rel="noopener">微信支付-H5支付</a></p><ul><li>由我们后台向微信支付发起统一下单请求</li><li>统一下单接口返回支付相关参数给商户后台，拼接成支付跳转url，商户通过此 url 去访问微信支付中间页</li><li>中间页会生成一个“weixin://wap/pay?” + 参数 这样一个scheme去调起微信客户端走到下单页面。</li></ul><p>补充说明:</p><pre><code>跳转url（mweb_url）示例： &quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx201711302016180757ed93760351075895&amp;package=2940730744&quot;scheme 示例: &quot;weixin://wap/pay?prepayid%3Dwx201711302016180757ed93760351075895&amp;package=2940730744&amp;noncestr=1512044179&amp;sign=df7fb3081e1eec19e5e3640ea97d31c3&quot;</code></pre><h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><p>再次声明，此处所说的问题在H5环境下并不是问题。我们讨论的是<strong>iOS上的App环境下使用微信H5支付的跳转问题</strong></p><p>以 <strong><a href="https://m.vip.com/" target="_blank" rel="noopener">唯品会</a></strong> 为例：在非 safari 浏览器下（比如 chrome 浏览器）打开唯品会 M站，走到提交微信支付订单，网页调起微信支付，尽管你设置了 redirect_url（回跳地址）并且关闭 safari，但是取消支付或者支付完成之后微信还是会跳回 safari 浏览器打开你的回调页面，而不是跳转至 chrome。这个时候就尴尬了，你得自己切换回到 chrome。如果我是用户，我至少会有点懵逼。</p><p>以 <strong><a href="https://m.jd.com/" target="_blank" rel="noopener">手机京东</a></strong> 为例：操作步骤同上，但是取消支付或者完成支付之后，不会跳回 safari，而是关闭支付页面，继续留在微信。虽然没有直接回到 chrome，但是这总比突然去打开 safari 更让人容易接受。</p><p>以上情况属于：</p><ul><li>特殊的运行环境：<strong>iOS上的原生App或者非safari浏览器(UC浏览器也不会跳回safari)</strong></li><li>指定的支付环境：<strong>微信H5支付</strong></li><li>奇怪的回跳逻辑：<strong>有的会打开safari，而有的并不会</strong></li></ul><p>我们的期望肯定是能回跳到发起微信支付的 App 是最好的，不过在这之前需要先弄清楚为什么会出现这样的回跳逻辑差异。</p><h2 id="分析差异"><a href="#分析差异" class="headerlink" title="分析差异"></a>分析差异</h2><h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><p>首先得分析两个M站的微信支付流程吧，上面提到过关键步骤就是：</p><p>普通的支付流程：后台发起统一下单请求 –&gt; 微信支付接口返回给你相关参数 –&gt; 根据参数去拼接一个 <strong>mweb_url</strong> 的地址，你需要做的就是 location.href = mweb_url –&gt; 这个页面里会生成一个 <strong>微信 scheme</strong> 地址，调起微信客户端支付。这是普通商户的，也是唯品会的H5支付流程。</p><p>通过抓包得来的 mweb_url 地址页面的关键 js 内容如下，微信 scheme 会在这个页面自动生成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    if (0 === 0) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> is_postmsg = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (is_postmsg == <span class="string">"1"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    parent.postMessage(<span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="javascript">                        action: <span class="string">"send_deeplink"</span>,</span></span><br><span class="line">                        data: &#123;</span><br><span class="line"><span class="javascript">                            deeplink: <span class="string">"weixin://wap/pay?prepayid%3Dwx20171204195948d0d40803800224970868&amp;package=121328958&amp;noncestr=1512388788&amp;sign=545a16c77fd27d98a3eaf23751ec6104"</span></span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="javascript">                    &#125;), <span class="string">""</span>);</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> url = <span class="string">"weixin://wap/pay?prepayid%3Dwx20171204195948d0d40803800224970868&amp;package=121328958&amp;noncestr=1512388788&amp;sign=545a16c77fd27d98a3eaf23751ec6104"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> redirect_url = <span class="string">"https://npay.vip.com/wap/cashier/doPay?paySn=17120467932547060971&amp;sid=D4D4043F87D714D61FDC13B1763BCA1FFF30491E&amp;t=1512388788060&amp;type=queryOrder&amp;orderSns=17120467932547"</span>;</span></span><br><span class="line">                    top.location.href = url;</span><br><span class="line"></span><br><span class="line">                    if (redirect_url) &#123;</span><br><span class="line">                        setTimeout(</span><br><span class="line"><span class="javascript">                            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                                top.location.href = redirect_url;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            5000</span><br><span class="line">                        );</span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">                        setTimeout(</span><br><span class="line"><span class="javascript">                            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                                <span class="built_in">window</span>.history.back();</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            5000);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">// );</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，京东并不是这么做的。</p><p>京东的微信支付流程：进入下单页面选择微信支付 –&gt; 前端发起 GET 请求后台 –&gt; 京东后台直接返回了<strong>微信 scheme</strong> 地址，（是直接返回了，而不是通过访问拼接的<strong>mweb_url</strong>地址做跳转，这一步普通商户也可以做到，但是可能也还是有差异的） –&gt; 根据此地址在当前支付页面 append 一个 A 标签，塞进此地址，自动触发点击事件 –&gt; 调起微信支付，M站的支付页面经过5秒的延时会弹出一个mask弹窗来触发查询支付订单操作。</p><h3 id="微信-scheme"><a href="#微信-scheme" class="headerlink" title="微信 scheme"></a>微信 scheme</h3><p>唯品会的：</p><pre><code>weixin://wap/pay?prepayid=wx20171204195948d0d40803800224970868&amp;package=121328958&amp;noncestr=1512388788&amp;sign=545a16c77fd27d98a3eaf23751ec6104</code></pre><p>手机京东的：</p><pre><code>weixin://wap/pay?appid=wxae3e8056daea8727&amp;noncestr=24bfde45b5790f04b1d096565157f6a4&amp;package=WAP&amp;prepayid=wx201712041702047d0d37c44f0850922294&amp;timestamp=1512378124&amp;sign=89BE2251D47BF1EEB48CA3C8D62A1967</code></pre><p>京东多了 appid，timestamp 参数，并且京东的 package 参数指定为 WAP，这是通过多次抓包得到的验证，<strong>package是固定的并且目测所有不发生回跳safari的都固定为WAP</strong>。appid 是微信分配的公众账号 ID，这个值每个商户是都有的，所以我们想当然的就这样去模仿京东的微信 scheme，但是到了微信下单页面，我们看到了这个报错：</p><p><img src="/assets/images/wx_H5.jpg" alt="微信报错"></p><h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><p>很显然这么做是行不通的，既然让你提供 appid 参数，肯定会做出相应验证。所以由此说明微信团队应该是有白名单的。</p><p>于是相继测试了许多大站的M站微信 H5 支付，目测 京东，美团，猫眼电影，大众点评，饿了么 都在白名单列。其他的类似唯品会，蘑菇街，聚美优品，一号店，去哪儿，途牛，携程都会回跳至 safari。</p><h2 id="不算完美的解决办法"><a href="#不算完美的解决办法" class="headerlink" title="不算完美的解决办法"></a>不算完美的解决办法</h2><p>目前针对这种情况，我们是无能为力的，自己开发的 iOS App 如果走的是微信H5支付，比如 web app，只能通过在safari 打开的回跳地址中<strong>自行添加自己应用的 scheme 地址调起应用</strong>，看过大多数 web app 都是这么做的。</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>虽然折腾了这么多，去看各大站的微信 H5 支付流程，去抓包微信跳转的 mweb_url 地址和微信 scheme 地址做对比和测试，去改后台请求微信支付接口的参数等等，这些都行不通，但是至少弄明白原来微信H5支付还有这种操作，希望能为一些开发者解惑。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信H5支付 </tag>
            
            <tag> 回跳safari </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活的苟且与诗的远方</title>
      <link href="/2017/07/26/%E7%94%9F%E6%B4%BB%E7%9A%84%E8%8B%9F%E4%B8%94%E5%92%8C%E8%AF%97%E7%9A%84%E8%BF%9C%E6%96%B9/"/>
      <url>/2017/07/26/%E7%94%9F%E6%B4%BB%E7%9A%84%E8%8B%9F%E4%B8%94%E5%92%8C%E8%AF%97%E7%9A%84%E8%BF%9C%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p>以前总想着未来会怎样，我会变成什么样子，有点患得患失的感觉，而当初的我把这理解为对自己负责，导致现在我来了北京。其实有的时候，珍惜当下，顺其自然才算是活出了自我。</p><p>不过我并不是很后悔，走出了那一步，就该想着下一步怎么走，至于上上步，走过来了就是走过来了。</p><p>经常看高晓松（矮大紧）的晓说，所以想写点东西时，这个标题就突然蹦到脑子里了，就是它了，因为我懒得想了。他的晓说虽然说有人考证有些是胡说八道，但是他的风格我喜欢，通俗易懂，很随性，就跟听段子似的，矮大紧还是个博学多才的人，听他讲他们音乐圈的事，从以前到现在，世道虽然变了，但是他们美好的回忆都印在他们的脑海里，特别喜欢他说起某个有名的人当年就是一屌丝什么的，然后各种机缘巧合，一夜成名，或者一直碌碌无为或者种种，就会感想到人的一生你越想把控越容易失去机会，不管世界怎么变，只要你保持你做人做事的准则，这世界还是在你脚下。往往当你想去抛弃一些迎合世界时，可能你会取得短暂的成功，但终究你会迷失自己，因为你已经没有标准了。</p><p>还有一点最近的感受，什么是聪明人？我认为聪明人并不是单纯的智商在线，能够敏锐的看到事物本质，动脑多于动手，头脑随时清晰，逻辑思维能力强的人算。而对于那些喜欢卖弄小聪明，走捷径，对反应慢的人表示鄙夷的人，我只能说：骚年，你还须修炼。</p><p>如今的我，空空如也，除了能工作和正常交流，没有其他技能和知识内涵，我知道我该看点书或者学点什么了，生活虽然苟且，但是不能做一具行尸走肉。</p><p>关于诗的远方，我喜欢一个人上路，但到目前为止，没走出去过一步。现在要试着把所想变成现实，好好生活</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式字面量模式与字符串模式</title>
      <link href="/2017/07/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/07/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><hr><h4 id="字面量模式"><a href="#字面量模式" class="headerlink" title="字面量模式"></a>字面量模式</h4><p> <code>js</code> 中通过 <code>RegExp</code> 类型来支持正则表达式，使用以下方法就可以创建一个正则表达式：</p><pre><code>var expression = / pattern / flags;</code></pre><p>每个表达式可带一个或多个 <code>flags</code>,用以表明正则表达式的行为。其匹配模式支持一下三种 <code>flags</code>：</p><pre><code>g: 表示全局模式，将被应用于所有字符串，而并不是在第一个匹配项立即结束i: 表示不区分大小写m: 表示多行（multiline）模式</code></pre><hr><h4 id="RegExp-构造函数模式"><a href="#RegExp-构造函数模式" class="headerlink" title="RegExp 构造函数模式"></a>RegExp 构造函数模式</h4><p>通过实例化 RegExp 构造函数对象，这里多说一句，在ECMAScript 3 中正则表达式字面量始终是共用一个 RegExp 实例，而构造函数创建每次则会创建一个新的实例化对象，但是在 ECMAScript 5 中已经明确规定，字面量创建正则表达式必须每次都像直接调用 RegExp 对象那样，各浏览器厂商都对此作出了修改。</p><p>通过此模式创建正则表达式，传入参数为字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式字面量模式</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[hello\]world/i</span>;</span><br><span class="line"></span><br><span class="line">pattern1.source; <span class="comment">//返回 “\[hello\]world”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式对象模式</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[hello\\]world"</span>, <span class="string">"i"</span>);</span><br><span class="line"></span><br><span class="line">pattern2.source; <span class="comment">//返回 “\[hello\]world”</span></span><br></pre></td></tr></table></figure><p>以上通过两种方式创建的同一含义的正则表达式，其 source 属性返回的都是正则表达式的字符串表示，值得注意的是返回的事按照字面量形式的字符串模式，而并不是你传入构造函数中的字符串模式，这里或许会有很多人搞混，直接把这个当成传入构造函数的字符串模式，然后进行一系列操作，然后可能就会一脸懵逼，怀疑智商。。。。。</p><p><b>传入构造函数中的字符串模式并不是正则表达式直接去外面的斜线，因为字符串模式中是需要双反斜杠 \ 来代替一个反斜杠 \ 的作用.</b></p><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两者相比而言,字面量模式显然更简洁更方便。有一点小差别就是采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。通常都会直接使用字面量形式创建，除非你的正则表达式需要在运行中才能生成，那就需要通过穿字符串的方式创建了。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 正则匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof vs instanceof</title>
      <link href="/2017/05/07/typeof%20vs%20instanceof/"/>
      <url>/2017/05/07/typeof%20vs%20instanceof/</url>
      
        <content type="html"><![CDATA[<p>工作中往往在判断变量类型的时候，会用到 typeof 和 instanceof ，前者在初学时用到的比较多，看过其他人对这两种方法的总结，其实理解并不难，但是好记性不如烂笔头，记录总结也可以更好的学习。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>可用于基本类型的判断，容易混淆的地方有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);   <span class="comment">//返回"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);   <span class="comment">//返回”object“</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>);       <span class="comment">//返回"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);   <span class="comment">//返回"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);   <span class="comment">//返回"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);       <span class="comment">//返回"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                    <span class="comment">//返回"object"   不要问为什么 这是个bug 注意就行</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>               <span class="comment">//返回"undefined"</span></span><br></pre></td></tr></table></figure><p>对于 object 类型，typeof 就不可靠了，所以这里可以用到 instanceof</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h4 id="1-可用于比较自定义对象"><a href="#1-可用于比较自定义对象" class="headerlink" title="1.可用于比较自定义对象"></a>1.可用于比较自定义对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span></span><br><span class="line">Bar.prototype = Foo;</span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="2-比较内置类型-尤其是-object-特殊类型"><a href="#2-比较内置类型-尤其是-object-特殊类型" class="headerlink" title="2.比较内置类型 尤其是 object 特殊类型"></a>2.比较内置类型 尤其是 object 特殊类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line"> object instanceof constructor</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line"> object 要检测的对象</span><br><span class="line"> constructor 构造函数</span><br><span class="line"></span><br><span class="line">规则</span><br><span class="line"> 检查 object 是否继承自 constructor.prototype，返回一个布尔值。</span><br><span class="line"> 注意：不是判断一个对象的类型</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>   <span class="comment">//false  null是一种"原型"数据类型 不是继承自object 因此返回false</span></span><br></pre></td></tr></table></figure><h3 id="跨窗口问题"><a href="#跨窗口问题" class="headerlink" title="跨窗口问题"></a>跨窗口问题</h3><p><b style="color:#dd1144;font-size: 12px;">以上两种类型判断仅限于同一 JavaScript 上下文的对象，不同的文档结构也就是不同的窗口中将会出错，因为他们的构造函数不是同一个实例</b></p><p>那么问题来了，如果是跨上下文环境判断对象可以怎样做呢</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>toString 方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。 toString 属性定义在 Object.prototype 上，因而所有对象都拥有 toString 方法。 但 Array, Date 等对象会重写从 Object.prototype 继承来的 toString， 所以最好用 Object.prototype.toString 来检测类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>);    <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>);  <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>);        <span class="comment">// [object Math]</span></span><br><span class="line">toString.call(<span class="number">3</span>);           <span class="comment">// [object Number]</span></span><br><span class="line">toString.call([]);          <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;);          <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>);   <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>);        <span class="comment">// [object Null]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//toString 也不是完美的，它无法检测用户自定义类型。 因为Object.prototype是不知道用户会创造什么类型的， 它只能检测ECMA标准中的那些内置类型。</span></span><br><span class="line">toString.call(<span class="keyword">new</span> Animal)   <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><b>typeof</b> 只能检测基本数据类型，对于 null 还有 Bug ；</p></li><li><p><b>instanceof</b> 适用于检测对象，它是基于原型链运作的；</p></li><li><p><b>toString</b> 适用于 ECMA 内置 JavaScript 类型（包括基本数据类型和内置对象）的类型判断；</p></li></ul><p>总之，如果你要判断的是基本数据类型或 JavaScript 内置对象，使用<b>toString</b>； 如果要判断的时自定义类型，请使用<b>instanceof</b>。</p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> typeof </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在北京</title>
      <link href="/2017/04/07/%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC/"/>
      <url>/2017/04/07/%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC/</url>
      
        <content type="html"><![CDATA[<pre><code>至少现在 我觉得不努力是种罪过</code></pre><p>一周多以前我还在成都，在一个很稳定很舒适的状态，然后想了一个晚上，不过后来睡着了，做了个决定去北京看看，以前只是想想而已，我觉得我并没有那个付诸行动的能力，但是当你对一个东西过于执着，这个能力就具备了。</p><p>自己想好了，再告诉家人，说话的时候吞吞吐吐，因为我知道他们担心，感觉对不起家人，但是最终还是同意了，说实话他们的支持是对我最大的鼓励。然后和这边谈，还ok，然后辞职，不得不说成都的同事都真的挺不错，只可惜，缘分短暂。之后就是过来了。</p><p>凌晨到的，感觉这边天亮的挺早，然后是得说普通话了，然后累死一天给自己找了个窝，要感谢一个姐姐来接我陪我找房，一个人我真的有可能就回去了。。。</p><p>第二天就开始上班，觉得现在已经差不多适应了，真心觉得自己是个随遇而安的人，给自己点个赞，嘿嘿。</p><p>今天是父亲生日，生日快乐。</p><p>一个人的时候感觉挺舒服，可以想事情不被打扰，可以慢悠悠，可以不出来了。。。</p><p>每天其实挺忙的，学的用的东西都跟以前不一样，不知道这样对以后有没有帮助，先学习学习再说吧，又是一个没有妹子的Team 我表示很无奈。。。</p><p>最近都没时间可以好好学点东西，只有来记流水账了。</p><pre><code>今天感受到了一种来自帝都的危机感，所以回来的路上想走回来，慢悠悠的，谁也不会催我，哼</code></pre>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以前 现在 以后</title>
      <link href="/2017/03/15/%E4%BB%A5%E5%89%8D-%E7%8E%B0%E5%9C%A8-%E4%BB%A5%E5%90%8E/"/>
      <url>/2017/03/15/%E4%BB%A5%E5%89%8D-%E7%8E%B0%E5%9C%A8-%E4%BB%A5%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h2><p>从小到大没遇过什么大波澜，成长还算正常，所以三观还算正常，有三五老友都是以前一起吃饭睡觉混下来的，没正儿八经谈过恋爱，但是却期待像俗人一样在大学里有那么一段儿，最好是能一直到老，估计每个女生都会这样想。大学里得偿所愿，到毕业了，然后我们分开了。</p><p>那段时间工作，情感交织在一起，感觉生活好好的给我上了一课，看似很合乎情理的毕业分手季，但是在每对人心中都有刻骨铭心的你们为什么分开，过去的一年里时常我会像总结学习经验一样回顾自己的感情，开始是很不好受的，不能接受，但是慢慢的那感觉如抽丝，我觉得应该是抽完了。。。</p><p>刚出校门觉得什么都新鲜，心里多年的蓝图终于可以自己亲手绘制了，所以做什么都一头扎进去，但是往往死脑筋，走了弯路，回头发现，心里骂自己傻逼。曾经质疑过自己，是不是得换行了，智商不够用啊，不管啦，先做了这个再说，然后做出来了又考虑是不是可以再坚持坚持，物理老师曾经说过，量还没有达到一定的积累，是不会有质的飞跃了，所以我觉得肯定是量不够，也不想那么多了，就是干。</p><p>上班，下班，上班，下班，周末，睡觉，看书，新朋友不想交，旧朋友不在身边，提不起兴趣去和别人多说一句，没事就是耳机，电影，这样的日子过的生活变的静悄悄的，却也死气沉沉，想找那种要新不新要旧不旧的朋友出门耍一下，想想还是算了，现在的人关系没有一定积累，谁愿意出来跟你耗时间，所以还是继续一个人呆着。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>感情可以翻篇了，这个是我不断给自己强调的。</p><p>把节奏慢下来，不要想着一口吃个胖子，到头来还是太浮，所以把每个知识点弄清楚才是最重要的，对于前端这件事情，我想认真对待，也不想什么换行了，喜欢就做，其他的优先级都没有这个高。</p><p>可以交一点新朋友啦，不要给自己画地为牢</p><p>什么都看开一点，发觉顺其自然才是王道，何必纠结于一些细想来根本没有意义的事情上。</p><p>活这么大最大的感悟：世界上根本不会有什么懂你的人或者理想的另一半，最懂你的就是你自己，不要期望从别人那里获得什么，你可以自己给你自己啊，给不了就看开一点，欲望不要那么强烈就什么都无所谓了</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>挣钱～   宁为玉碎，不为瓦全，做好孤独一生和与家人奋战到底的准备</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组 45 度斜线遍历输出 js 实现</title>
      <link href="/2017/03/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%8445%E5%BA%A6%E6%96%9C%E7%BA%BF%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%20js%20%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/03/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%8445%E5%BA%A6%E6%96%9C%E7%BA%BF%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%20js%20%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h3><p><img src="/img/2017-03-10-a.png" alt="二维数组"></p><h3 id="一言不合上代码"><a href="#一言不合上代码" class="headerlink" title="一言不合上代码"></a>一言不合上代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [],</span><br><span class="line">m = <span class="number">6</span>,</span><br><span class="line">n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line"><span class="keyword">let</span> tmp = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">tmp.push(<span class="string">'['</span> + i + j + <span class="string">']'</span>)</span><br><span class="line">&#125;</span><br><span class="line">arr.push(tmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">arr,m,n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">getNext(arr,i,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j= <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">getNext(arr,m<span class="number">-1</span>,j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i&lt;m &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;n )&#123;</span><br><span class="line"><span class="built_in">console</span>.log(arr[i][j])</span><br><span class="line">getNext(arr,i<span class="number">-1</span>,j+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(arr,m,n)</span><br></pre></td></tr></table></figure><h3 id="结果显示"><a href="#结果显示" class="headerlink" title="结果显示"></a>结果显示</h3><p>由于篇幅限制，只显示了上半部分的打印</p><p><img src="/img/2017-03-10-b.png" alt="二维数组"></p>]]></content>
      
      
      <categories>
          
          <category> fontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 二维数组 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首-2016</title>
      <link href="/2017/03/09/%E5%9B%9E%E9%A6%96-2016/"/>
      <url>/2017/03/09/%E5%9B%9E%E9%A6%96-2016/</url>
      
        <content type="html"><![CDATA[<h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>匆匆忙忙的答辩,匆匆忙忙的聚会,匆匆忙忙的毕业留影,寝室合照,不知道互相可以倾诉什么,只知道我们毕业了,东西要搬走,请的假快到了,匆匆忙忙的回去上班,我们就毕业了.因为在学校里有一段不美好的经历，所以到现在一点都不怀念那个大学…</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>努力工作过,曾经持续工作40多个小时,体会了一把什么叫只知道机械运动,然后手指僵硬.收获了很多工作心得,找到了程序员的正确姿势,各种剪不断理还乱的情况下,决定休息一段时间,来年再战.</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>为母亲大人鞍前马后了一次,知道了父母是这个世界上最爱你的人,当然我也爱他们,哥哥嫂子结婚了,我帮忙装的新房,结个婚真累…但是并没有瘦!两个侄儿会陆续降生,希望他们健健康康,帅帅的,美美哒.</p><h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>此处省略三万字…</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>好好沉淀 多思考少说话  重新开始 迎接侄儿们的到来,我要当姑姑了(终于涨了一辈…)</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
